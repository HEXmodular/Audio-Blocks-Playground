import { BlockDefinition, BlockInstance, BlockParameter, NativeBlock } from "@interfaces/block";
import * as Tone from 'tone';

const WORKLET_NAME = 'byte-beat-processor';
const WORKLET_PATH = 'worklets/ByteBeatProcessor.js';

const BLOCK_DEFINITION: BlockDefinition = {
  id: 'bytebeat-processor-v1',
  name: 'ByteBeat Player',
  description: 'Plays audio generated from a bytebeat formula.',
  category: '8-bit',
  // runsAtAudioRate: true,
  inputs: [
    { id: 'trigger_in', name: 'Trigger Input', type: 'trigger', description: 'Reset counter' }
  ],
  outputs: [
    { id: 'output', name: 'Audio Output', type: 'audio', description: 'The generated bytebeat audio.' }
  ],
  parameters: [
    {
      id: 'formula',
      name: 'Formula',
      type: 'text_input',
      defaultValue: "t&t>>8",
      description: 'The bytebeat formula (e.g.,t&t>>8)'
    }
  ],
};


// ByteBeatOptions now includes initial parameters and definition for constructor-based setup
interface ByteBeatNodeOptions extends Tone.ToneAudioNodeOptions {
  sampleRate?: number; // Kept for consistency, though fixed in worklet for formula
  initialParams?: BlockParameter[];//  BlockParameter[]; // для загрузки сохраненных параметров из localstorage или файла
  // definition?: BlockDefinition; // для хранения дополнительной информации, которая вне Tone.ToneAudioNode
}

export class ByteBeatPlayer extends Tone.ToneAudioNode<ByteBeatNodeOptions> implements NativeBlock {
  readonly name: string = BLOCK_DEFINITION.name;
  input = undefined; // This is a native AudioWorkletNode, managed by this ToneAudioNode
  output = new Tone.Gain(1); // This is a native AudioWorkletNode, managed by this ToneAudioNode
  workletNode: AudioWorkletNode | null = null; // Store the worklet node instance
  gateSubscriptions: Tone.Emitter<string>[] = [];

  // private internalDefinition: BlockDefinition; // Store definition for fallback access

  private static workletLoaded = false;

  // Constructor for the ToneAudioNode part
  constructor(options?: ByteBeatNodeOptions) { // options are no longer partial for required ones like context
    super(options);
    // для того, чтобы сервис соединений получил к чему конектиться сразу
    // this.input = this.output = new Tone.Gain(1);
    this.init();

    Tone.getTransport().on('stop', () => {
      this.workletNode?.disconnect(); // Disconnect worklet node on transport stop
    })
    Tone.getTransport().on('start', () => {
      this.workletNode?.port.postMessage('start'); // Notify worklet to start processing on transport start
      this.workletNode?.connect(this.output.input); // Connect internal gain to the worklet node    
    })
  }

  private async init() {
    if (!ByteBeatPlayer.workletLoaded) {
      await ByteBeatPlayer.loadWorklet().catch(e => {
        console.error("[ByteBeatPlayer] CRITICAL: Error loading worklet in constructor:", e);
      });
    }


    this.workletNode = Tone.getContext().createAudioWorkletNode(WORKLET_NAME, {
      outputChannelCount: [2],
    });
    this.workletNode.connect(this.output.input); // Connect internal gain to the worklet node    

    // Set initial formula from parameters passed in options
    // const initialFormulaParam = ByteBeatPlayer.getDefinition().parameters.find(p => p.id === 'formula')?.defaultValue;
    // this.setFormula(initialFormulaParam);
    // console.log(`[ByteBeatPlayer] Initial formula set to: "${initialFormulaParam}"`);
  }

  // Method to send the formula string to the AudioWorklet
  public setFormula(formula: string): this {
    if (this.output && this.output.port) {
      this.output.port.postMessage({ formula });
      console.log(`[ByteBeatPlayer] Sent formula to worklet: ${formula}`);
    } else {
      console.warn("[ByteBeatPlayer] Output node or port not available to set formula.");
    }
    return this;
  }

  // Static methods and public instance methods for lifecycle management by BlockStateManager
  public static getDefinition(): BlockDefinition {
    return BLOCK_DEFINITION;
  }

  // TODO вынести в переиспользуемое
  public static async loadWorklet() {
    if (ByteBeatPlayer.workletLoaded) {
      return;
    }
    try {
      // Use Tone.context to add the module
      await Tone.getContext().addAudioWorkletModule(WORKLET_PATH);
      ByteBeatPlayer.workletLoaded = true;
      console.log(`[ByteBeatNativeBlock] worklet loaded successfully via Tone.context.`);
    } catch (e) {
      console.error(`[ByteBeatNativeBlock] Error loading worklet:`, e);
    }
  }

  // Public method for BlockStateManager to update this node instance from block data
  public updateFromBlockInstance(instance: BlockInstance): void {
    console.log(`[ByteBeatPlayer updateFromBlockInstance] Updating instance ${instance.instanceId} with parameters:`, instance);
    if (!instance?.parameters) {
      return;
    }
    //
    // TODO разобраться с начальными параметрами которых нет в панели
    //

    // const formulaParam = instance.parameters.find(p => p.id === 'formula');
    // let formulaToSet = this.internalDefinition.parameters.find(p => p.id === 'formula')?.defaultValue as string; // Fallback to definition's default

    // if (formulaParam && typeof formulaParam.currentValue === 'string' && formulaParam.currentValue.trim() !== "") {
    //   formulaToSet = formulaParam.currentValue;
    // } else {
    //   console.warn(`[ByteBeatPlayer updateFromBlockInstance] Invalid or empty formula for instance ${instance.instanceId}. Using default: "${formulaToSet}".`);
    // }
    // this.setFormula(formulaToSet);
  }

  // для очевидной передачи эммитера от входящего блока
  public setSubscription(emitters: { [key: string]: Tone.Emitter }): void {
    // сейчас обрабатывается только одно подключение
    // а их может быть множество
    // нужно будет передавать от кого пришло сообщение
    // и удалять если этот блок удалили
    if (this.gateSubscriptions.length) {
      return
    }
    this.gateSubscriptions.push(
      emitters.trigger_in?.on?.('gate_change', (payload) => {
        console.log("[ByteBeatPlayer] Gate input received, resetting counter in worklet.", payload);
      })
    );
    this.gateSubscriptions.push(
      emitters.trigger_in?.on?.('trigger', (payload) => {
        console.log("[ByteBeatPlayer] Trigger input received, resetting counter in worklet.", payload);
      })
    );
  }



}



