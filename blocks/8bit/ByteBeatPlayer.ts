import { BlockDefinition, BlockInstance, BlockParameter } from "@interfaces/block";
import * as Tone from 'tone';

const WORKLET_NAME = 'byte-beat-processor';
const WORKLET_PATH = 'worklets/ByteBeatProcessor.js';
const NAME = 'ByteBeat Player';

// ByteBeatOptions now includes initial parameters and definition for constructor-based setup
interface ByteBeatNodeOptions extends Tone.ToneAudioNodeOptions {
  sampleRate?: number; // Kept for consistency, though fixed in worklet for formula
  initialParams?: BlockParameter[];//  BlockParameter[]; // для загрузки сохраненных параметров из localstorage или файла
  // definition?: BlockDefinition; // для хранения дополнительной информации, которая вне Tone.ToneAudioNode
}

export class ByteBeatPlayer extends Tone.ToneAudioNode<ByteBeatNodeOptions> {
  readonly name: string = NAME;
  input: AudioWorkletNode | undefined = undefined; // This is a native AudioWorkletNode, managed by this ToneAudioNode
  output: AudioWorkletNode | undefined = undefined; // This is a native AudioWorkletNode, managed by this ToneAudioNode

  private internalDefinition: BlockDefinition; // Store definition for fallback access

  private static workletLoaded = false;

  // Constructor for the ToneAudioNode part
  constructor(options?: ByteBeatNodeOptions) { // options are no longer partial for required ones like context
    super(options);
    // if (!options.definition) {
    //   throw new Error("[ByteBeatPlayer] Definition is required in options.");
    // }
    // this.internalDefinition = options.definition;
    this.init();
  }

  private async init() {
    if (!ByteBeatPlayer.workletLoaded) {
      await ByteBeatPlayer.loadWorklet().catch(e => {
        console.error("[ByteBeatPlayer] CRITICAL: Error loading worklet in constructor:", e);
      });
    }

    const workletNode = Tone.getContext().createAudioWorkletNode(WORKLET_NAME, {
      outputChannelCount: [2],
    });
    this.input = this.output = workletNode;

    console.log("[ByteBeatPlayer] AudioWorkletNode instance created.");

    // Set initial formula from parameters passed in options
    const initialFormulaParam = ByteBeatPlayer.getDefinition().parameters.find(p => p.id === 'formula')?.defaultValue;
    this.setFormula(initialFormulaParam);
    // console.log(`[ByteBeatPlayer] Initial formula set to: "${initialFormulaParam}"`);
  }

  // Method to send the formula string to the AudioWorklet
  public setFormula(formula: string): this {
    if (this.output && this.output.port) {
      this.output.port.postMessage({ formula });
      console.log(`[ByteBeatPlayer] Sent formula to worklet: ${formula}`);
    } else {
      console.warn("[ByteBeatPlayer] Output node or port not available to set formula.");
    }
    return this;
  }

  // Overridden dispose from Tone.ToneAudioNode
  dispose(): this {
    super.dispose(); // Handles disconnection and GC for Tone.js
    // Any additional custom disposal logic for ByteBeatPlayer can go here.
    // The workletNode (this.input/this.output) is handled by super.dispose()
    // if it's correctly assigned to this.input/this.output.
    console.log("[ByteBeatPlayer] Disposed.");
    return this;
  }

  // Static methods and public instance methods for lifecycle management by AudioNodeManager

  public static getDefinition(): BlockDefinition {
    return {
      id: 'bytebeat-processor-v1',
      name: NAME,
      description: 'Plays audio generated from a bytebeat formula.',
      // runsAtAudioRate: true,
      inputs: [],
      outputs: [
        { id: 'output', name: 'Audio Output', type: 'audio', description: 'The generated bytebeat audio.' }
      ],
      parameters: [
        {
          id: 'formula',
          name: 'Formula',
          type: 'text_input',
          defaultValue: "t&t>>8",
          description: 'The bytebeat formula (e.g.,t&t>>8)'
        }
      ],
    };
  }

  // TODO вынести в переиспользуемое
  public static async loadWorklet() {
    if (ByteBeatPlayer.workletLoaded) {
      return;
    }
    try {
      // Use Tone.context to add the module
      await Tone.getContext().addAudioWorkletModule(WORKLET_PATH);
      ByteBeatPlayer.workletLoaded = true;
      console.log(`[ByteBeatNativeBlock] worklet loaded successfully via Tone.context.`);
    } catch (e) {
      console.error(`[ByteBeatNativeBlock] Error loading worklet:`, e);
    }
  }

  // Public method for AudioNodeManager to update this node instance from block data
  public updateFromBlockInstance(instance: BlockInstance): void {
    if (!instance?.parameters) {
      return;
    }
    // const formulaParam = instance.parameters.find(p => p.id === 'formula');
    // let formulaToSet = this.internalDefinition.parameters.find(p => p.id === 'formula')?.defaultValue as string; // Fallback to definition's default

    // if (formulaParam && typeof formulaParam.currentValue === 'string' && formulaParam.currentValue.trim() !== "") {
    //   formulaToSet = formulaParam.currentValue;
    // } else {
    //   console.warn(`[ByteBeatPlayer updateFromBlockInstance] Invalid or empty formula for instance ${instance.instanceId}. Using default: "${formulaToSet}".`);
    // }
    // this.setFormula(formulaToSet);
  }

  // dispose method is inherited from Tone.ToneAudioNode and overridden if needed (already done above)
  // and overridden above. No need for a separate one here unless CreatableNode
  // requires a dispose with a different signature or purpose.
  // The existing `dispose(): this` from ToneAudioNode should suffice.
  // If CreatableNode's dispose is meant to be called by AudioNodeManager on the handler,
  // then the current `dispose` method on `this` (ByteBeatPlayer instance) will be called.
}



