import { BlockDefinition, BlockInstance, BlockParameter, NativeBlock } from "@interfaces/block";
import { Emitter, getContext, getTransport, Gain, ToneAudioNode, ToneAudioNodeOptions } from "tone";

const WORKLET_NAME = 'byte-beat-processor';
const WORKLET_PATH = 'worklets/ByteBeatProcessor.js';

const BLOCK_DEFINITION: BlockDefinition = {
  id: 'bytebeat-processor-v1',
  name: 'ByteBeat Player',
  description: 'Plays audio generated from a bytebeat formula.',
  category: '8-bit',
  // runsAtAudioRate: true,
  inputs: [
    { id: 'reset_counter', name: 'Reset', type: 'trigger', description: 'Reset counter' }
  ],
  outputs: [
    { id: 'output', name: 'Audio', type: 'audio', description: 'The generated bytebeat audio.' }
  ],
  parameters: [
    {
      id: 'formula',
      name: 'Formula',
      type: 'text_input',
      defaultValue: "t&t>>8",
      description: 'The bytebeat formula (e.g.,t&t>>8)'
    }
  ],
};


// ByteBeatOptions now includes initial parameters and definition for constructor-based setup
interface ByteBeatNodeOptions extends ToneAudioNodeOptions {
  sampleRate?: number; // Kept for consistency, though fixed in worklet for formula
  initialParams?: BlockParameter[];//  BlockParameter[]; // для загрузки сохраненных параметров из localstorage или файла
  // definition?: BlockDefinition; // для хранения дополнительной информации, которая вне Tone.ToneAudioNode
}

export class ByteBeatPlayer extends ToneAudioNode<ByteBeatNodeOptions> implements NativeBlock {
  readonly name: string = BLOCK_DEFINITION.name;
  input = undefined; // This is a native AudioWorkletNode, managed by this ToneAudioNode
  workletNode: AudioWorkletNode | null = null; // Store the worklet node instance
  // output;
  output = new Gain(1); // This is a native AudioWorkletNode, managed by this ToneAudioNode
  formula?: string;

  private _emitter = new Emitter();

  // private internalDefinition: BlockDefinition; // Store definition for fallback access

  private static workletLoaded = false;
  private static workletLoading: Promise<void> | null = null;

  // Constructor for the ToneAudioNode part
  constructor(options?: ByteBeatNodeOptions) { // options are no longer partial for required ones like context
    super(options);
    // для того, чтобы сервис соединений получил к чему конектиться сразу
    // this.input = this.output = new Tone.Gain(1);
    this.init();

    getTransport().on('stop', () => {
      this.workletNode?.disconnect(); // Disconnect worklet node on transport stop
    })
    getTransport().on('start', () => {
      this.workletNode?.connect(this.output.input.context.destination); // Connect internal gain to the worklet node    
      this.workletNode?.port.postMessage('start'); // Notify worklet to start processing on transport start
    })

    this._emitter.on('reset_counter', (payload) => {
      // console.log("[StepSequencerBlock] Enable gate input received.", payload);
      // this.handleGateIn(payload);
    })
  }

  private async init() {
    if (!ByteBeatPlayer.workletLoading) {
      // ByteBeatPlayer.workletLoaded = true;
      ByteBeatPlayer.workletLoading = ByteBeatPlayer.loadWorklet()
      await ByteBeatPlayer.workletLoading.catch((e: any) => {
        console.error("[ByteBeatPlayer] CRITICAL: Error loading worklet in constructor:", e);
      });
    } else {
      await ByteBeatPlayer.workletLoading;
    }

    // console.log("[ByteBeatPlayer] Creating worklet node with UUID:", WORKLET_NAME);
    
    // await Tone.getContext().addAudioWorkletModule(WORKLET_PATH);
    this.workletNode = getContext().createAudioWorkletNode(WORKLET_NAME, {
      outputChannelCount: [2],
    });


    // await audioContext.audioWorklet.addModule('my-worklet-processor.js');
    // const myWorkletNode1 = new AudioWorkletNode(audioContext, 'my-worklet-processor');
    // myWorkletNode1.connect(audioContext.destination);


    this.setFormula();

    this.workletNode.onprocessorerror = (error) => {
      console.error("[ByteBeatPlayer] Processor error:", error);
    }
  }

  // Method to send the formula string to the AudioWorklet
  public setFormula(): this {
    if (this.workletNode?.port) {
      this.workletNode.port.postMessage({ formula: this.formula });
      // console.log(`[ByteBeatPlayer] Sent formula to worklet: ${this.formula}`);
    } else {
      console.warn("[ByteBeatPlayer] Output node or port not available to set formula.");
    }
    return this;
  }

  // Static methods and public instance methods for lifecycle management by BlockStateManager
  public static getDefinition(): BlockDefinition {
    return BLOCK_DEFINITION;
  }

  // TODO вынести в переиспользуемое
  public static async loadWorklet() {
    if (ByteBeatPlayer.workletLoaded) {
      return;
    }
    try {
      // Use Tone.context to add the module
      // console.log("[ByteBeatPlayer] Loading worklet with context:", Tone.getContext());
      await getContext().addAudioWorkletModule(WORKLET_PATH);
      ByteBeatPlayer.workletLoaded = true;
      console.log(`[ByteBeatNativeBlock] worklet loaded successfully via Tone.context.`);
    } catch (e) {
      console.error(`[ByteBeatNativeBlock] Error loading worklet:`, e);
    }
  }

  // Public method for BlockStateManager to update this node instance from block data
  public updateFromBlockInstance(instance: BlockInstance): void {
    console.log(`[ByteBeatPlayer updateFromBlockInstance] Updating instance ${instance.instanceId} with parameters:`, instance);
    if (!instance?.parameters) {
      return;
    }
    //
    // TODO разобраться с начальными параметрами которых нет в панели
    //

    const formulaParam = instance.parameters.find(p => p.id === 'formula');
    // let formulaToSet = this.internalDefinition.parameters.find(p => p.id === 'formula')?.defaultValue as string; // Fallback to definition's default
    if (formulaParam && typeof formulaParam.currentValue === 'string' && formulaParam.currentValue.trim() !== "") {
      this.formula = formulaParam.currentValue;
      this.setFormula();
    } else {
      console.warn(`[ByteBeatPlayer updateFromBlockInstance] Invalid or empty formula for instance ${instance.instanceId}.`);
    }
    
  }

  // для очевидной передачи эммитера от входящего блока
  // public setSubscription(emitters: { [key: string]: Tone.Emitter }): void {
  //   // сейчас обрабатывается только одно подключение
  //   // а их может быть множество
  //   // нужно будет передавать от кого пришло сообщение
  //   // и удалять если этот блок удалили
  //   if (this.gateSubscriptions.length) {
  //     return
  //   }
  //   this.gateSubscriptions.push(
  //     emitters.trigger_in?.on?.('gate_change', (payload) => {
  //       console.log("[ByteBeatPlayer] Gate input received, resetting counter in worklet.", payload);
  //     })
  //   );
  //   this.gateSubscriptions.push(
  //     emitters.trigger_in?.on?.('trigger', (payload) => {
  //       console.log("[ByteBeatPlayer] Trigger input received, resetting counter in worklet.", payload);
  //     })
  //   );
  // }



}



