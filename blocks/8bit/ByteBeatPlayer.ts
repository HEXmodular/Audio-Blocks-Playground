import { BlockDefinition, BlockInstance, BlockParameter, NativeBlock } from "@interfaces/block";
import * as Tone from 'tone';

const WORKLET_NAME = 'byte-beat-processor';
const WORKLET_PATH = 'worklets/ByteBeatProcessor.js';

const BLOCK_DEFINITION: BlockDefinition = {
  id: 'bytebeat-processor-v1',
  name: 'ByteBeat Player',
  description: 'Plays audio generated from a bytebeat formula.',
  // runsAtAudioRate: true,
  inputs: [],
  outputs: [
    { id: 'output', name: 'Audio Output', type: 'audio', description: 'The generated bytebeat audio.' }
  ],
  parameters: [
    {
      id: 'formula',
      name: 'Formula',
      type: 'text_input',
      defaultValue: "t&t>>8",
      description: 'The bytebeat formula (e.g.,t&t>>8)'
    }
  ],
};

// ByteBeatOptions now includes initial parameters and definition for constructor-based setup
interface ByteBeatNodeOptions extends Tone.ToneAudioNodeOptions {
  sampleRate?: number; // Kept for consistency, though fixed in worklet for formula
  initialParams?: BlockParameter[];//  BlockParameter[]; // для загрузки сохраненных параметров из localstorage или файла
  // definition?: BlockDefinition; // для хранения дополнительной информации, которая вне Tone.ToneAudioNode
}

export class ByteBeatPlayer extends Tone.ToneAudioNode<ByteBeatNodeOptions> implements NativeBlock {
  readonly name: string = BLOCK_DEFINITION.name;
  input = undefined; // This is a native AudioWorkletNode, managed by this ToneAudioNode
  output = new Tone.Gain(1); // This is a native AudioWorkletNode, managed by this ToneAudioNode

  // private internalDefinition: BlockDefinition; // Store definition for fallback access

  private static workletLoaded = false;

  // Constructor for the ToneAudioNode part
  constructor(options?: ByteBeatNodeOptions) { // options are no longer partial for required ones like context
    super(options);
    // для того, чтобы сервис соединений получил к чему конектиться сразу
    // this.input = this.output = new Tone.Gain(1);
    this.init();
  }

  private async init() {
    if (!ByteBeatPlayer.workletLoaded) {
      await ByteBeatPlayer.loadWorklet().catch(e => {
        console.error("[ByteBeatPlayer] CRITICAL: Error loading worklet in constructor:", e);
      });
    }

    const workletNode = Tone.getContext().createAudioWorkletNode(WORKLET_NAME, {
      outputChannelCount: [2],
    });
    workletNode.connect(this.output.input); // Connect internal gain to the worklet node    

    // Set initial formula from parameters passed in options
    // const initialFormulaParam = ByteBeatPlayer.getDefinition().parameters.find(p => p.id === 'formula')?.defaultValue;
    // this.setFormula(initialFormulaParam);
    // console.log(`[ByteBeatPlayer] Initial formula set to: "${initialFormulaParam}"`);
  }

  // Method to send the formula string to the AudioWorklet
  public setFormula(formula: string): this {
    if (this.output && this.output.port) {
      this.output.port.postMessage({ formula });
      console.log(`[ByteBeatPlayer] Sent formula to worklet: ${formula}`);
    } else {
      console.warn("[ByteBeatPlayer] Output node or port not available to set formula.");
    }
    return this;
  }

  // Static methods and public instance methods for lifecycle management by BlockStateManager
  public static getDefinition(): BlockDefinition {
    return BLOCK_DEFINITION;
  }

  // TODO вынести в переиспользуемое
  public static async loadWorklet() {
    if (ByteBeatPlayer.workletLoaded) {
      return;
    }
    try {
      // Use Tone.context to add the module
      await Tone.getContext().addAudioWorkletModule(WORKLET_PATH);
      ByteBeatPlayer.workletLoaded = true;
      console.log(`[ByteBeatNativeBlock] worklet loaded successfully via Tone.context.`);
    } catch (e) {
      console.error(`[ByteBeatNativeBlock] Error loading worklet:`, e);
    }
  }

  // Public method for BlockStateManager to update this node instance from block data
  public updateFromBlockInstance(instance: BlockInstance): void {
    console.log(`[ByteBeatPlayer updateFromBlockInstance] Updating instance ${instance.instanceId} with parameters:`, instance);
    if (!instance?.parameters) {
      return;
    }
    // const formulaParam = instance.parameters.find(p => p.id === 'formula');
    // let formulaToSet = this.internalDefinition.parameters.find(p => p.id === 'formula')?.defaultValue as string; // Fallback to definition's default

    // if (formulaParam && typeof formulaParam.currentValue === 'string' && formulaParam.currentValue.trim() !== "") {
    //   formulaToSet = formulaParam.currentValue;
    // } else {
    //   console.warn(`[ByteBeatPlayer updateFromBlockInstance] Invalid or empty formula for instance ${instance.instanceId}. Using default: "${formulaToSet}".`);
    // }
    // this.setFormula(formulaToSet);
  }
}



