import { CreatableNode } from "../CreatableNode";
import { BlockDefinition, BlockInstance, BlockParameter, ManagedNativeNodeInfo } from "@interfaces/common";
import * as Tone from 'tone';

interface ByteBeatOptions extends Tone.ToneAudioNodeOptions {
  sampleRate: number;
}

const WORKLET_NAME = 'byte-beat-processor';
const WORKLET_PATH = 'worklets/ByteBeatProcessor.js';

// This class extends Tone.ToneAudioNode to create a custom audio node
// that uses an AudioWorklet to process bytebeat audio.
class ByteBeatToneAudio extends Tone.ToneAudioNode<ByteBeatOptions> {
  readonly name: string = 'ByteBeatStringPlayer';
  readonly input: AudioWorkletNode;
  readonly output: AudioWorkletNode;

  readonly sampleRate: Tone.Param<"number">

  // для отправки иных типов данных отличных от чисел в AudioWorklet
  setFormula(formula: string): this {
    this.output.port.postMessage({ formula });
    return this;
  }

  constructor(options?: Partial<ByteBeatOptions>) {
    super(options);

    // 1. Создаем наш AudioWorkletNode, как и раньше
    const worklet = this.context.createAudioWorkletNode(WORKLET_NAME, {
      outputChannelCount: [2]
    });

    // 2. Назначаем его одновременно и входом, и выходом нашего компонента
    this.input = this.output = worklet;

    // 3. Создаем Tone.Param из параметра нашего worklet'а
    const sampleRate = worklet.parameters.get('sampleRate');

    this.sampleRate = new Tone.Param({
      context: this.context,
      param: sampleRate,
      value: options?.sampleRate ?? 8000,
      units: "number"
    });

    console.log("[ByteBeatToneAudioWorklet] Created AudioWorkletNode with formula parameter:", this.sampleRate);
  }

  dispose(): this {
    super.dispose();
    // Нативный узел будет отключен вызовом super.dispose(),
    // так как он является и входом, и выходом.
    // Но для надежности можно вызвать disconnect() явно.
    this.input.disconnect();
    return this;
  }

}

export class ByteBeatNativeBlock implements CreatableNode {
  public readonly name: string = "ByteBeat";
  private workletNode?: ByteBeatToneAudio;
  private static workletLoaded = false;

  constructor() {
    ByteBeatNativeBlock.loadWorklet()
  }

  public static getDefinition(): BlockDefinition {
    return {
      id: 'bytebeat-processor-v1',
      name: 'ByteBeat Player',
      description: 'Plays audio generated from a bytebeat formula.',
      runsAtAudioRate: true,
      inputs: [], // No audio inputs for now, could add CV later
      outputs: [
        { id: 'output', name: 'Audio Output', type: 'audio', description: 'The generated bytebeat audio.' }
      ],
      parameters: [ // This should be an array of Parameter definitions, not BlockParameter instances
        {
          id: 'formula',
          name: 'Formula',
          type: 'text_input',
          defaultValue: "t&t>>8",
          description: 'The bytebeat formula (e.g.,t&t>>8)'
        }
      ],
    };
  }


  public static async loadWorklet() {
    if (!ByteBeatNativeBlock.workletLoaded) {
      try {
        // Use Tone.context to add the module
        await Tone.getContext().addAudioWorkletModule(WORKLET_PATH);
        ByteBeatNativeBlock.workletLoaded = true;
        console.log(`[ByteBeatNativeBlock] worklet loaded successfully via Tone.context.`);
      } catch (e) {
        console.error(`[ByteBeatNativeBlock] Error loading ${WORKLET_NAME} worklet via Tone.context:`, e);
        throw e; // Re-throw to allow callers to handle
      }
    }
  }

  // Implementation for CreatableNode interface
  createNode(
    instanceId: string, // This 'id' is the instanceId of the block
    definition: BlockDefinition, // The static definition of this block
    initialParams: BlockParameter[] // The initial parameters for this specific instance
  ): ManagedNativeNodeInfo {
    if (!this.workletNode) {
      this.workletNode = new ByteBeatToneAudio();
    }

    // The ByteBeatNode itself is the main output node
    return {
      instanceId,
      definition, // Store the definition used to create this instance
      node: this.workletNode, // The primary AudioNode for connection graph
      mainProcessingNode: this.workletNode, // Node that does the core processing
      nodeForInputConnections: this.workletNode, // Typically the same as 'node' if no separate input proxy
      nodeForOutputConnections: this.workletNode, // Typically the same as 'node' if no separate output proxy
      paramTargetsForCv: new Map(), // No direct AudioParam CV targets in this version
      internalState: {}, // Any internal state not part of parameters
      // inputs: definition.inputs || [], // Reflect inputs from definition
      // outputs: definition.outputs || [], // Reflect outputs from definition
    };
  }

  // Implementation for CreatableNode interface
  updateNodeParams(
    nodeInfo: ManagedNativeNodeInfo, // Contains the AudioWorkletNode instance
    instance: BlockInstance // Contains the current parameters of the block instance
  ): void {
    if (!this.workletNode || !instance.parameters) {
      console.warn("[ByteBeatNativeBlock] WorkletNode or parameters not available for update.", this.workletNode, instance.parameters);
      return;
    }

    this.workletNode.setFormula(instance.parameters.find(p => p.id === 'formula')?.currentValue || "")
  }

  public dispose(): void {
    this.workletNode?.dispose();
    this.workletNode?.disconnect();
    this.workletNode = undefined;
  }
}
