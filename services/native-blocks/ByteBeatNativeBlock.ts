import { CreatableNode } from "./CreatableNode";
import { BlockDefinition, BlockInstance, BlockParameter, ManagedNativeNodeInfo } from "@interfaces/common";
import * as Tone from 'tone';

interface ByteBeatOptions extends Tone.ToneAudioNodeOptions {
  // formula: string;
}

const WORKLET_NAME = 'byte-beat-processor';
const WORKLET_PATH = 'worklets/ByteBeatProcessor.js';

// This class extends Tone.ToneAudioNode to create a custom audio node
// that uses an AudioWorklet to process bytebeat audio.
class ByteBeatToneAudio extends Tone.ToneAudioNode<ByteBeatOptions> {
  readonly name: string = 'ByteBeatStringPlayer';
  readonly input: AudioWorkletNode;
  readonly output: AudioWorkletNode;

  constructor(options?: Partial<ByteBeatOptions>) {
    super(options);

    // 1. Создаем наш AudioWorkletNode, как и раньше
    const worklet = this.context.createAudioWorkletNode(WORKLET_NAME, {
      outputChannelCount: [2]
    });

    // 2. Назначаем его одновременно и входом, и выходом нашего компонента
    this.input = this.output = worklet;

    // 3. Создаем Tone.Param из параметра нашего worklet'а
    const formula = worklet.parameters.get('formula');
    console.log("[ByteBeatToneAudioWorklet] Created AudioWorkletNode with formula parameter:", formula);
  }

  dispose(): this {
    super.dispose();
    // Нативный узел будет отключен вызовом super.dispose(),
    // так как он является и входом, и выходом.
    // Но для надежности можно вызвать disconnect() явно.
    this.input.disconnect();
    return this;
  }

}

export class ByteBeatNativeBlock implements CreatableNode {
  public readonly name: string = "ByteBeat";
  private workletNode?: Tone.ToneAudioNode;
  private static workletLoaded = false;

  constructor() {
    ByteBeatNativeBlock.loadWorklet()
  }

  public static getDefinition(): BlockDefinition {
    return {
      id: 'bytebeat-processor-v1',
      name: 'ByteBeat Player',
      description: 'Plays audio generated from a bytebeat formula.',
      runsAtAudioRate: true,
      inputs: [], // No audio inputs for now, could add CV later
      outputs: [
        { id: 'output', name: 'Audio Output', type: 'audio', description: 'The generated bytebeat audio.' }
      ],
      parameters: [ // This should be an array of Parameter definitions, not BlockParameter instances
        {
          id: 'formula',
          name: 'Formula',
          type: 'text_input',
          defaultValue: "(t >> 10) * 42",
          description: 'The bytebeat formula (e.g., (t >> 10) * 42)'
        }
      ],
      isCreatable: true, // Mark that this block uses the CreatableNode pattern
    };
  }


  public static async loadWorklet() {
    if (!ByteBeatNativeBlock.workletLoaded) {
      try {
        // Use Tone.context to add the module
        await Tone.getContext().addAudioWorkletModule(WORKLET_PATH);
        ByteBeatNativeBlock.workletLoaded = true;
        console.log(`[ByteBeatNativeBlock] worklet loaded successfully via Tone.context.`);
      } catch (e) {
        console.error(`[ByteBeatNativeBlock] Error loading ${WORKLET_NAME} worklet via Tone.context:`, e);
        throw e; // Re-throw to allow callers to handle
      }
    }
  }

  // Implementation for CreatableNode interface
  createNode(
    instanceId: string, // This 'id' is the instanceId of the block
    definition: BlockDefinition, // The static definition of this block
    initialParams: BlockParameter[] // The initial parameters for this specific instance
  ): ManagedNativeNodeInfo {
    if (!this.workletNode) {
      this.workletNode = new ByteBeatToneAudio();
    }

    // The ByteBeatNode itself is the main output node
    return {
      instanceId,
      definition, // Store the definition used to create this instance
      node: this.workletNode, // The primary AudioNode for connection graph
      mainProcessingNode: this.workletNode, // Node that does the core processing
      nodeForInputConnections: this.workletNode, // Typically the same as 'node' if no separate input proxy
      nodeForOutputConnections: this.workletNode, // Typically the same as 'node' if no separate output proxy
      paramTargetsForCv: new Map(), // No direct AudioParam CV targets in this version
      internalState: {}, // Any internal state not part of parameters
      // inputs: definition.inputs || [], // Reflect inputs from definition
      // outputs: definition.outputs || [], // Reflect outputs from definition
    };
  }

  // Implementation for CreatableNode interface
  updateNodeParams(
    nodeInfo: ManagedNativeNodeInfo, // Contains the AudioWorkletNode instance
    instance: BlockInstance // Contains the current parameters of the block instance
  ): void {
    console.log("[ByteBeatNativeBlock] updateNodeParams called for instance:", instance);
    if (!this.workletNode || !instance.parameters) {
      console.warn("[ByteBeatNativeBlock] WorkletNode or parameters not available for update.", this.workletNode, instance.parameters);
      return;
    }

    // const formulaParam = instance.parameters.find(p => p.id === 'formula');
    // if (formulaParam && formulaParam.currentValue !== this.parameters.formula.currentValue) {
    //   const newFormula = formulaParam.currentValue as string;
    //   this.parameters.formula.currentValue = newFormula; // Update internal representation
    //   this.workletNode.port.postMessage({ formula: newFormula });
    //   console.log(`[ByteBeatNativeBlock] Updated formula to: ${newFormula} for instance ${instance.id}`);
    // }
  }

  public dispose(): void {
    this.workletNode?.dispose();
    this.workletNode?.disconnect();
    this.workletNode = undefined;
    // console.log(`[ByteBeatNativeBlock] Disposed instance ${this.id}`);
  }
}
