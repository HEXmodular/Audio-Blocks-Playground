{"audioEngineService":{"_audioContext":{},"_masterGainNode":{},"_isAudioGloballyEnabled":false,"_audioInitializationError":null,"_availableOutputDevices":[{"deviceId":"","kind":"audiooutput","label":"","groupId":""}],"_selectedSinkId":"","_subscribers":[null,null],"_outputWorkletConnections":{},"_audioContextService":{"context":{},"masterGainNode":{}},"audioWorkletManager":{"isAudioWorkletSystemReady":false,"audioInitializationErrorLocal":null,"dynamicallyRegisteredDefs":[{"id":"system-audio-output-v1","name":"Audio Output","description":"Plays the incoming audio signal. Contains an internal GainNode for volume control which then feeds a SampleBufferProcessor AudioWorklet (acting as a sink). The input port connects to this internal GainNode.","runsAtAudioRate":true,"inputs":[{"id":"audio_in","name":"Audio Input","type":"audio","description":"Signal to play. Connects to the internal volume GainNode."}],"outputs":[],"parameters":[{"id":"volume","name":"Volume","type":"slider","min":0,"max":1,"step":0.01,"defaultValue":0.7,"description":"Output volume level (controls an internal GainNode AudioParam)"}],"logicCode":"","audioWorkletProcessorName":"sample-buffer-processor","audioWorkletCode":"\n    class SampleBufferProcessor extends AudioWorkletProcessor {\n      static get parameterDescriptors() {\n        return [];\n      }\n\n      constructor(options) {\n        super(options);\n        this.instanceId = options?.processorOptions?.instanceId || 'UnknownSampleBufferWorklet';\n        this.recentSamples = new Float32Array(1024); // Store last 1024 samples\n        this.recentSamplesWritePtr = 0;\n\n        this.port.onmessage = (event) => {\n          if (event.data?.type === 'GET_RECENT_SAMPLES') {\n            const orderedSamples = new Float32Array(this.recentSamples.length);\n            let readPtr = this.recentSamplesWritePtr;\n            for (let i = 0; i < this.recentSamples.length; i++) {\n              orderedSamples[i] = this.recentSamples[readPtr];\n              readPtr = (readPtr + 1) % this.recentSamples.length;\n            }\n            this.port.postMessage({ type: 'RECENT_SAMPLES_DATA', samples: orderedSamples });\n          }\n        };\n      }\n\n      process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        const output = outputs[0];\n\n        if (input && input.length > 0 && output && output.length > 0) {\n          const inputChannel = input[0];\n          const outputChannel = output[0];\n          if (inputChannel && outputChannel) {\n            for (let i = 0; i < outputChannel.length; ++i) {\n              const sample = inputChannel[i] !== undefined ? inputChannel[i] : 0;\n              outputChannel[i] = sample;\n              this.recentSamples[this.recentSamplesWritePtr] = sample;\n              this.recentSamplesWritePtr = (this.recentSamplesWritePtr + 1) % this.recentSamples.length;\n            }\n          }\n        } else if (output && output.length > 0) {\n          const outputChannel = output[0];\n          if (outputChannel) {\n            for (let i = 0; i < outputChannel.length; ++i) {\n              outputChannel[i] = 0;\n              this.recentSamples[this.recentSamplesWritePtr] = 0;\n              this.recentSamplesWritePtr = (this.recentSamplesWritePtr + 1) % this.recentSamples.length;\n            }\n          }\n        }\n        return true;\n      }\n    }\n    // IMPORTANT: The registerProcessor call will be done by the host environment (useAudioEngine)\n    ","isAiGenerated":false,"initialPrompt":""}],"audioContext":{},"registeredWorkletNamesRef":{},"managedWorkletNodesRef":{}},"nativeNodeManager":{"audioContext":{},"managedNativeNodesRef":{},"blockHandlers":{}},"lyriaServiceManager":{"audioContext":{},"masterGainNode":{},"managedLyriaServiceInstancesRef":{}},"audioGraphConnectorService":{"activeWebAudioConnections":{}}},"blockStateManager":{"_initializationDone":true,"_blockDefinitions":[{"id":"system-audio-output-v1","name":"Audio Output","description":"Plays the incoming audio signal. Contains an internal GainNode for volume control which then feeds a SampleBufferProcessor AudioWorklet (acting as a sink). The input port connects to this internal GainNode.","runsAtAudioRate":true,"inputs":[{"id":"audio_in","name":"Audio Input","type":"audio","description":"Signal to play. Connects to the internal volume GainNode."}],"outputs":[],"parameters":[{"id":"volume","name":"Volume","type":"slider","defaultValue":0.7,"min":0,"max":1,"step":0.01,"description":"Output volume level (controls an internal GainNode AudioParam)"}],"logicCode":"// The 'audio_in' port is connected to this block's internal GainNode by the host audio engine.\n// The 'volume' parameter is used by useAudioEngine to control this internal GainNode's gain AudioParam.\n// This logicCode itself does not directly interact with the worklet or process audio.\n// __custom_block_logger__('Audio Output main-thread: Host manages audio routing and volume for this block.');\nreturn {};","initialPrompt":"System block: Audio Output. Plays audio from its input. Has a volume parameter that controls an internal GainNode. The GainNode then feeds a SampleBufferProcessor AudioWorklet.","audioWorkletProcessorName":"sample-buffer-processor","audioWorkletCode":"\nclass SampleBufferProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [];\n  }\n\n  constructor(options) {\n    super(options);\n    this.instanceId = options?.processorOptions?.instanceId || 'UnknownSampleBufferWorklet';\n    this.recentSamples = new Float32Array(1024); // Store last 1024 samples\n    this.recentSamplesWritePtr = 0;\n\n    this.port.onmessage = (event) => {\n      if (event.data?.type === 'GET_RECENT_SAMPLES') {\n        // To return samples in chronological order (oldest to newest)\n        // we create a new array and fill it by reading from the circular buffer.\n        const orderedSamples = new Float32Array(this.recentSamples.length);\n        let readPtr = this.recentSamplesWritePtr;\n        for (let i = 0; i < this.recentSamples.length; i++) {\n          orderedSamples[i] = this.recentSamples[readPtr];\n          readPtr = (readPtr + 1) % this.recentSamples.length;\n        }\n        this.port.postMessage({ type: 'RECENT_SAMPLES_DATA', samples: orderedSamples });\n      }\n      // Example of a previous message type, can be kept or removed if not used.\n      // if (event.data?.type === 'clearBuffer') {\n      //   // console.log(`${this.instanceId}: Clear buffer message received`);\n      // }\n    };\n  }\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0];\n\n    if (input && input.length > 0 && output && output.length > 0) {\n      const inputChannel = input[0];\n      const outputChannel = output[0];\n      if (inputChannel && outputChannel) {\n        for (let i = 0; i < outputChannel.length; ++i) {\n          const sample = inputChannel[i] !== undefined ? inputChannel[i] : 0;\n          outputChannel[i] = sample;\n\n          // Store in circular buffer\n          this.recentSamples[this.recentSamplesWritePtr] = sample;\n          this.recentSamplesWritePtr = (this.recentSamplesWritePtr + 1) % this.recentSamples.length;\n        }\n      }\n    } else if (output && output.length > 0) {\n      const outputChannel = output[0];\n      if (outputChannel) {\n        for (let i = 0; i < outputChannel.length; ++i) {\n          outputChannel[i] = 0;\n           // Store silence in circular buffer if no input\n          this.recentSamples[this.recentSamplesWritePtr] = 0;\n          this.recentSamplesWritePtr = (this.recentSamplesWritePtr + 1) % this.recentSamples.length;\n        }\n      }\n    }\n    return true;\n  }\n}\n// IMPORTANT: The registerProcessor call will be done by the host environment (useAudioEngine)\n","isAiGenerated":false},{"id":"oscillator-v1","name":"Oscillator (Worklet)","description":"Generates a waveform (sine, square, saw, triangle) using an AudioWorklet. Supports phase reset via trigger.","runsAtAudioRate":true,"inputs":[{"id":"freq_in","name":"Frequency CV","type":"audio","description":"Modulates frequency AudioParam directly in Web Audio graph.","audioParamTarget":"frequency"},{"id":"trigger_in","name":"Trigger","type":"trigger","description":"Restarts phase on trigger (handled by logicCode via postMessageToWorklet)"}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"The generated audio signal (from AudioWorklet)"}],"parameters":[{"id":"frequency","name":"Frequency","type":"slider","defaultValue":220,"min":20,"max":5000,"step":1,"description":"Base frequency in Hz for the AudioParam","isFrequency":true},{"id":"waveform","name":"Waveform","type":"select","defaultValue":"sine","options":[{"value":"sine","label":"Sine"},{"value":"square","label":"Square"},{"value":"sawtooth","label":"Sawtooth"},{"value":"triangle","label":"Triangle"}],"description":"Shape of the waveform, controlled via port message to worklet"},{"id":"gain","name":"Gain/CV Depth","type":"slider","defaultValue":0.5,"min":0,"max":200,"step":0.1,"description":"Output amplitude or CV modulation depth. Controls the gain AudioParam in the worklet."}],"logicCode":"// Main-thread logic for Oscillator. Audio is generated and output by its associated AudioWorklet.\n// AudioParams (frequency, gain) are set by the host (App.tsx) based on 'params' values.\n// 'freq_in' (type 'audio') is connected directly to the 'frequency' AudioParam by the host if a connection exists. This logicCode does not process 'freq_in'.\n// This logicCode handles 'trigger_in' and 'waveform' parameter changes by sending messages to the worklet.\n\nconst triggerInputVal = inputs.trigger_in; // This is a non-audio trigger signal\nconst currentWaveform = params.waveform;\n\nif (internalState.lastWaveform !== currentWaveform) {\n  if (postMessageToWorklet) {\n    postMessageToWorklet({ type: 'SET_WAVEFORM', waveform: currentWaveform });\n    __custom_block_logger__(`Waveform changed to: ${currentWaveform}`);\n  }\n  internalState.lastWaveform = currentWaveform;\n}\n\n// For trigger inputs, it's common to detect a rising edge (false to true)\nif (triggerInputVal === true && (internalState.prevTriggerState === false || internalState.prevTriggerState === undefined || internalState.prevTriggerState === null)) {\n  if (postMessageToWorklet) {\n    postMessageToWorklet({ type: 'TRIGGER_PHASE_RESET' });\n     __custom_block_logger__('Phase reset triggered for worklet.');\n  }\n}\ninternalState.prevTriggerState = triggerInputVal; // Store the current state for next comparison\n\nreturn internalState;","initialPrompt":"Create a basic audio oscillator block with frequency, waveform (sine, square, sawtooth, triangle), and gain parameters. It should accept frequency control voltage input (as an audio-rate signal for direct AudioParam modulation) and a trigger input to reset phase. It should output an audio signal. This version will use an AudioWorklet for sound generation.","audioWorkletProcessorName":"oscillator-processor","audioWorkletCode":"\nclass OscillatorProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [\n      { name: 'frequency', defaultValue: 440, minValue: 0.01, maxValue: 22050, automationRate: 'a-rate' },\n      { name: 'gain', defaultValue: 0.5, minValue: 0, maxValue: 200, automationRate: 'a-rate' }, // Max gain increased\n    ];\n  }\n\n  constructor(options) {\n    super(options);\n    this.phase = 0;\n    this.waveform = (options?.processorOptions?.waveform) || 'sine';\n    this.instanceId = options?.processorOptions?.instanceId || 'UnknownOscillatorWorklet';\n    // sampleRate is global in AudioWorkletGlobalScope\n\n    this.port.onmessage = (event) => {\n      if (event.data?.type === 'SET_WAVEFORM') {\n        this.waveform = event.data.waveform;\n      }\n      if (event.data?.type === 'TRIGGER_PHASE_RESET') {\n        this.phase = 0;\n      }\n    };\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannel = output[0];\n\n    const frequencyParams = parameters.frequency;\n    const gainParams = parameters.gain;\n\n    for (let i = 0; i < outputChannel.length; ++i) {\n      const frequency = frequencyParams.length > 1 ? frequencyParams[i] : frequencyParams[0];\n      const gain = gainParams.length > 1 ? gainParams[i] : gainParams[0];\n\n      const increment = frequency / sampleRate; // sampleRate is from AudioWorkletGlobalScope\n      this.phase = (this.phase + increment) % 1.0;\n\n      let sampleValue = 0;\n      switch (this.waveform) {\n        case 'sine':\n          sampleValue = Math.sin(this.phase * 2 * Math.PI);\n          break;\n        case 'square':\n          sampleValue = this.phase < 0.5 ? 1 : -1;\n          break;\n        case 'sawtooth':\n          sampleValue = (this.phase * 2) - 1;\n          break;\n        case 'triangle':\n          sampleValue = 2 * (0.5 - Math.abs(this.phase - 0.5)) * 2 - 1;\n          break;\n        default:\n          sampleValue = Math.sin(this.phase * 2 * Math.PI);\n      }\n      outputChannel[i] = sampleValue * gain;\n    }\n    return true;\n  }\n}\n// IMPORTANT: The registerProcessor call will be done by the host environment (useAudioEngine)\n// after extracting this code string. Do not include registerProcessor here.\n","isAiGenerated":false},{"id":"manual-gate-v1","name":"Manual Gate","description":"Provides a manual gate signal via a toggle UI parameter.","inputs":[],"outputs":[{"id":"gate_out","name":"Gate Output","type":"gate","description":"Boolean gate signal."}],"parameters":[{"id":"gate_active","name":"Gate Active","type":"toggle","defaultValue":false,"description":"Controls the state of the gate output."}],"logicCode":"// Outputs the state of the 'gate_active' parameter.\nconst gateState = params.gate_active;\nsetOutput('gate_out', gateState);\n// __custom_block_logger__(`Manual Gate output: ${gateState}`);\nreturn {};","initialPrompt":"Create a Manual Gate block. It should have one toggle parameter \"Gate Active\" and one output port \"Gate Output\" of type gate. The output should reflect the state of the toggle.","isAiGenerated":false},{"id":"step-sequencer-v1","name":"Step Sequencer","description":"A step sequencer with trigger input, and trigger/gate outputs. Can run on internal BPM clock or external trigger.","inputs":[{"id":"ext_trigger_in","name":"External Trigger","type":"trigger","description":"Advances the sequencer one step if Run Mode is External."}],"outputs":[{"id":"trigger_out","name":"Trigger Output","type":"trigger","description":"Outputs a trigger when an active step is played."},{"id":"gate_out","name":"Gate Output","type":"gate","description":"Outputs a gate signal (high for active step duration, low otherwise)."}],"parameters":[{"id":"steps_pattern","name":"Steps Pattern","type":"step_sequencer_ui","defaultValue":[true,false,true,false,true,false,true,false],"description":"Pattern of active steps.","steps":8},{"id":"run_mode","name":"Run Mode","type":"select","defaultValue":"internal_bpm","options":[{"value":"internal_bpm","label":"Internal BPM"},{"value":"external_trigger","label":"External Trigger"}],"description":"Clock source for the sequencer."},{"id":"bpm_fraction_rate","name":"Rate (BPM Fraction)","type":"select","defaultValue":0.25,"options":[{"value":4,"label":"1 Bar (4/4)"},{"value":2,"label":"1/2 Note"},{"value":1.5,"label":"Dotted 1/4 Note"},{"value":1,"label":"1/4 Note (Beat)"},{"value":0.75,"label":"Dotted 1/8 Note"},{"value":0.5,"label":"1/8 Note"},{"value":0.3333333333333333,"label":"1/4 Triplet"},{"value":0.25,"label":"1/16 Note"},{"value":0.16666666666666666,"label":"1/8 Triplet"},{"value":0.125,"label":"1/32 Note"},{"value":0.08333333333333333,"label":"1/16 Triplet"}],"description":"Sequencer step rate when in Internal BPM mode."},{"id":"num_steps","name":"Number of Steps","type":"slider","defaultValue":8,"min":1,"max":16,"step":1,"description":"Total number of steps in the sequence."}],"logicCode":"// Step Sequencer Logic\nconst runMode = params.run_mode;\nconst externalTrigger = inputs.ext_trigger_in;\nconst stepsPattern = params.steps_pattern; // boolean[]\nconst numSteps = Math.max(1, Math.min(16, params.num_steps || stepsPattern.length)); // Clamp num_steps\n\nlet currentStep = internalState.currentStepIndex || 0;\nlet timeSinceLastInternalStep = internalState.timeSinceLastInternalStep || 0;\nlet gateHigh = false;\nlet triggerOut = null;\n\nconst bpm = audioContextInfo ? audioContextInfo.bpm : 120;\nconst sampleRate = audioContextInfo ? audioContextInfo.sampleRate : 44100;\nconst samplesPerBlock = 128; // Assuming typical AudioWorklet block size for timing\n\nconst bpmFraction = parseFloat(params.bpm_fraction_rate);\nconst beatsPerStep = bpmFraction; // e.g., 0.25 for 1/16th notes means each step is 0.25 beats\nconst secondsPerBeat = 60.0 / bpm;\nconst secondsPerStep = secondsPerBeat * beatsPerStep;\nconst samplesPerStep = Math.round(secondsPerStep * sampleRate);\n\nfunction advanceStep() {\n  currentStep = (currentStep + 1) % numSteps;\n  internalState.currentStepIndex = currentStep;\n  if (stepsPattern[currentStep]) {\n    triggerOut = true; // Output trigger on active step\n    gateHigh = true;\n    __custom_block_logger__(`Step ${currentStep + 1} triggered. Output: ${stepsPattern[currentStep]}`);\n  } else {\n    gateHigh = false;\n    // __custom_block_logger__(`Step ${currentStep + 1} not active.`);\n  }\n}\n\nif (runMode === 'internal_bpm') {\n  timeSinceLastInternalStep += samplesPerBlock;\n  if (timeSinceLastInternalStep >= samplesPerStep) {\n    advanceStep();\n    timeSinceLastInternalStep = 0; // Reset counter\n  }\n} else if (runMode === 'external_trigger') {\n  if (externalTrigger === true && (internalState.prevExtTriggerState === false || internalState.prevExtTriggerState === undefined || internalState.prevExtTriggerState === null)) {\n    advanceStep();\n  }\n}\n\ninternalState.timeSinceLastInternalStep = timeSinceLastInternalStep;\ninternalState.prevExtTriggerState = externalTrigger;\n\nsetOutput('trigger_out', triggerOut);\nsetOutput('gate_out', gateHigh);\n\nreturn internalState;","initialPrompt":"Create a Step Sequencer block. Parameters: \"Steps Pattern\" (step_sequencer_ui, default 8 steps), \"Run Mode\" (select: Internal BPM, External Trigger), \"Rate (BPM Fraction)\" (select: musical divisions for BPM sync), \"Number of Steps\" (slider 1-16). Inputs: \"External Trigger\". Outputs: \"Trigger Output\", \"Gate Output\". Logic should handle step advancement based on mode and timing.","isAiGenerated":false},{"id":"probability-sequencer-v1","name":"Probability Sequencer","description":"Step sequencer where each step has a probability of triggering.","inputs":[{"id":"ext_trigger_in","name":"External Trigger","type":"trigger","description":"Advances the sequencer one step if Run Mode is External."}],"outputs":[{"id":"trigger_out","name":"Trigger Output","type":"trigger","description":"Outputs a trigger when an active step successfully plays based on its probability."},{"id":"gate_out","name":"Gate Output","type":"gate","description":"Outputs a gate signal if a step successfully plays."}],"parameters":[{"id":"steps_pattern","name":"Steps Pattern (Activation)","type":"step_sequencer_ui","defaultValue":[true,true,true,true,true,true,true,true],"description":"Determines if a step CAN play. Probability applies if active.","steps":8},{"id":"probabilities","name":"Probabilities (0-100%)","type":"text_input","defaultValue":"100,100,100,100,75,75,50,50","description":"Comma-separated probabilities for each step (0-100). Length should match number of steps."},{"id":"run_mode","name":"Run Mode","type":"select","defaultValue":"internal_bpm","options":[{"value":"internal_bpm","label":"Internal BPM"},{"value":"external_trigger","label":"External Trigger"}],"description":"Clock source for the sequencer."},{"id":"bpm_fraction_rate","name":"Rate (BPM Fraction)","type":"select","defaultValue":0.25,"options":[{"value":4,"label":"1 Bar (4/4)"},{"value":2,"label":"1/2 Note"},{"value":1.5,"label":"Dotted 1/4 Note"},{"value":1,"label":"1/4 Note (Beat)"},{"value":0.75,"label":"Dotted 1/8 Note"},{"value":0.5,"label":"1/8 Note"},{"value":0.3333333333333333,"label":"1/4 Triplet"},{"value":0.25,"label":"1/16 Note"},{"value":0.16666666666666666,"label":"1/8 Triplet"},{"value":0.125,"label":"1/32 Note"},{"value":0.08333333333333333,"label":"1/16 Triplet"}],"description":"Sequencer step rate when in Internal BPM mode."},{"id":"num_steps","name":"Number of Steps","type":"slider","defaultValue":8,"min":1,"max":16,"step":1,"description":"Total number of steps in the sequence. Ensure Probabilities string matches this."}],"logicCode":"// Probability Sequencer Logic\nconst runMode = params.run_mode;\nconst externalTrigger = inputs.ext_trigger_in;\nconst stepsPattern = params.steps_pattern; // boolean[] for activation\nconst numSteps = Math.max(1, Math.min(16, params.num_steps || stepsPattern.length));\n\nconst probabilitiesStr = params.probabilities || \"\";\nconst probabilityValues = probabilitiesStr.split(',').map(p => parseFloat(p.trim()) / 100.0); // Convert to 0.0-1.0\n\nlet currentStep = internalState.currentStepIndex || 0;\nlet timeSinceLastInternalStep = internalState.timeSinceLastInternalStep || 0;\nlet gateHigh = false;\nlet triggerOut = null;\n\nconst bpm = audioContextInfo ? audioContextInfo.bpm : 120;\nconst sampleRate = audioContextInfo ? audioContextInfo.sampleRate : 44100;\nconst samplesPerBlock = 128; \n\nconst bpmFraction = parseFloat(params.bpm_fraction_rate);\nconst beatsPerStep = bpmFraction;\nconst secondsPerBeat = 60.0 / bpm;\nconst secondsPerStep = secondsPerBeat * beatsPerStep;\nconst samplesPerStep = Math.round(secondsPerStep * sampleRate);\n\nfunction advanceStepAndCheckProbability() {\n  currentStep = (currentStep + 1) % numSteps;\n  internalState.currentStepIndex = currentStep;\n  \n  const stepIsActive = stepsPattern[currentStep] === true;\n  const stepProbability = (probabilityValues[currentStep] !== undefined && !isNaN(probabilityValues[currentStep])) ? probabilityValues[currentStep] : 1.0;\n\n  if (stepIsActive && Math.random() < stepProbability) {\n    triggerOut = true;\n    gateHigh = true;\n    __custom_block_logger__(`Step ${currentStep + 1} triggered (Prob: ${(stepProbability*100).toFixed(0)}%).`);\n  } else {\n    gateHigh = false;\n    // __custom_block_logger__(`Step ${currentStep + 1} did not trigger (Active: ${stepIsActive}, Prob: ${(stepProbability*100).toFixed(0)}%).`);\n  }\n}\n\nif (runMode === 'internal_bpm') {\n  timeSinceLastInternalStep += samplesPerBlock;\n  if (timeSinceLastInternalStep >= samplesPerStep) {\n    advanceStepAndCheckProbability();\n    timeSinceLastInternalStep = 0;\n  }\n} else if (runMode === 'external_trigger') {\n  if (externalTrigger === true && (internalState.prevExtTriggerState === false || internalState.prevExtTriggerState === undefined || internalState.prevExtTriggerState === null)) {\n    advanceStepAndCheckProbability();\n  }\n}\n\ninternalState.timeSinceLastInternalStep = timeSinceLastInternalStep;\ninternalState.prevExtTriggerState = externalTrigger;\n\nsetOutput('trigger_out', triggerOut);\nsetOutput('gate_out', gateHigh);\n\nreturn internalState;","initialPrompt":"Create a Probability Sequencer block. Parameters: \"Steps Pattern (Activation)\" (step_sequencer_ui), \"Probabilities (0-100%)\" (text_input, comma-separated), \"Run Mode\", \"Rate (BPM Fraction)\", \"Number of Steps\". Inputs: \"External Trigger\". Outputs: \"Trigger Output\", \"Gate Output\". Logic should consider step activation and its probability.","isAiGenerated":false},{"id":"rule-110-automaton-v1","name":"Rule 110 Automaton","description":"1D cellular automaton (Rule 110). Outputs next state as a number. Can run on internal clock or external trigger. Includes LFO mode.","inputs":[{"id":"trigger_in","name":"Trigger","type":"trigger","description":"Advances automaton one step."},{"id":"numeric_state_in","name":"Numeric State In","type":"number","description":"Overrides internal state with this number if connected."}],"outputs":[{"id":"numeric_state_out","name":"Numeric State Out","type":"number","description":"The numeric representation of the core cells of the next state."}],"parameters":[{"id":"core_length","name":"Core Length (N)","type":"slider","defaultValue":8,"min":1,"max":16,"step":1,"description":"Number of core cells (excluding boundaries)."},{"id":"initial_pattern_plus_boundaries","name":"Pattern + Boundaries","type":"step_sequencer_ui","defaultValue":[false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],"description":"Initial state for L-Boundary, N Core cells, R-Boundary, and unused cells. Max 16 core + 2 boundaries = 18 total.","steps":18},{"id":"run_mode","name":"Run Mode","type":"select","defaultValue":"internal_trigger","options":[{"value":"internal_trigger","label":"Internal Trigger"},{"value":"external_trigger","label":"External Trigger"},{"value":"lfo","label":"LFO Mode"}],"description":"Clock source for automaton updates."},{"id":"internal_freq_hz","name":"Internal Freq (Hz)","type":"number_input","defaultValue":10,"min":0.01,"max":8000,"description":"Frequency for Internal Trigger or LFO mode (Hz).","isFrequency":true},{"id":"lfo_bpm_sync_rate","name":"LFO BPM Sync Rate","type":"select","defaultValue":0.25,"options":[{"value":4,"label":"1 Bar (4/4)"},{"value":2,"label":"1/2 Note"},{"value":1.5,"label":"Dotted 1/4 Note"},{"value":1,"label":"1/4 Note (Beat)"},{"value":0.75,"label":"Dotted 1/8 Note"},{"value":0.5,"label":"1/8 Note"},{"value":0.3333333333333333,"label":"1/4 Triplet"},{"value":0.25,"label":"1/16 Note"},{"value":0.16666666666666666,"label":"1/8 Triplet"},{"value":0.125,"label":"1/32 Note"},{"value":0.08333333333333333,"label":"1/16 Triplet"}],"description":"Rate for LFO mode if BPM synced (overrides Hz if selected)."},{"id":"lfo_sync_to_bpm","name":"LFO Sync to BPM","type":"toggle","defaultValue":false,"description":"Enable BPM sync for LFO mode."}],"logicCode":"const coreLength = Math.max(1, Math.min(16, params.core_length));\nconst totalPatternLength = coreLength + 2; // L-Boundary + Core + R-Boundary\nlet currentPattern = internalState.currentPattern || [...(params.initial_pattern_plus_boundaries || [])].slice(0, totalPatternLength);\nif (currentPattern.length !== totalPatternLength) { // Adjust if coreLength changed\n  const defaultPattern = [...(params.initial_pattern_plus_boundaries || [])];\n  currentPattern = Array(totalPatternLength).fill(false).map((_,i) => defaultPattern[i] === true);\n}\n\nconst numericStateIn = inputs.numeric_state_in;\nif (numericStateIn !== null && numericStateIn !== undefined && typeof numericStateIn === 'number' && isFinite(numericStateIn)) {\n  const maxVal = (1 << coreLength) -1;\n  const intVal = Math.max(0, Math.min(maxVal, Math.floor(numericStateIn)));\n  for (let i = 0; i < coreLength; i++) {\n    currentPattern[i + 1] = (intVal & (1 << (coreLength - 1 - i))) !== 0;\n  }\n  // __custom_block_logger__(`External state applied: ${intVal}, Pattern: ${currentPattern.slice(1, coreLength+1).map(b=>b?1:0).join('')}`);\n}\n\nconst RULE_110_MAP = [0,1,1,1,0,1,1,0]; // For neighborhoods: 111 to 000 -> output bit\n\nfunction applyRule110(left, middle, right) {\n  const index = (left ? 4 : 0) + (middle ? 2 : 0) + (right ? 1 : 0);\n  return RULE_110_MAP[index] === 1;\n}\n\nfunction stepAutomaton() {\n  const nextPattern = [...currentPattern];\n  for (let i = 0; i < coreLength; ++i) { // Iterate core cells\n    const leftNeighbor = currentPattern[i];     // Cell at index i is left neighbor of core cell i+1\n    const currentCell  = currentPattern[i + 1]; // Core cell\n    const rightNeighbor= currentPattern[i + 2]; // Cell at index i+2 is right neighbor of core cell i+1\n    nextPattern[i + 1] = applyRule110(leftNeighbor, currentCell, rightNeighbor);\n  }\n  currentPattern = nextPattern;\n  internalState.currentPattern = currentPattern;\n\n  let numericOutput = 0;\n  for (let i = 0; i < coreLength; ++i) {\n    if (currentPattern[i + 1]) { // Core cells are from index 1 to coreLength\n      numericOutput |= (1 << (coreLength - 1 - i));\n    }\n  }\n  setOutput('numeric_state_out', numericOutput);\n  // __custom_block_logger__(`Stepped. Core: ${currentPattern.slice(1, coreLength+1).map(b=>b?1:0).join('')}, Out: ${numericOutput}`);\n}\n\n// Timing logic\nconst runMode = params.run_mode;\nconst externalTrigger = inputs.trigger_in;\nconst internalFreqHz = params.internal_freq_hz;\nconst lfoBpmSync = params.lfo_sync_to_bpm;\nconst lfoBpmFraction = parseFloat(params.lfo_bpm_sync_rate);\n\nconst bpm = audioContextInfo ? audioContextInfo.bpm : 120;\nconst sampleRate = audioContextInfo ? audioContextInfo.sampleRate : 44100;\nconst samplesPerBlock = 128;\n\nlet effectiveFreqHz;\nif (runMode === 'lfo' && lfoBpmSync) {\n  const beatsPerStep = lfoBpmFraction;\n  const secondsPerBeat = 60.0 / bpm;\n  const secondsPerStep = secondsPerBeat * beatsPerStep;\n  effectiveFreqHz = 1.0 / secondsPerStep;\n} else {\n  effectiveFreqHz = internalFreqHz;\n}\n\nconst samplesPerStepInternal = Math.max(1, Math.round(sampleRate / effectiveFreqHz));\nlet timeSinceLastInternalStep = internalState.timeSinceLastInternalStep || 0;\n\nif (runMode === 'internal_trigger' || runMode === 'lfo') {\n  timeSinceLastInternalStep += samplesPerBlock;\n  if (timeSinceLastInternalStep >= samplesPerStepInternal) {\n    stepAutomaton();\n    timeSinceLastInternalStep = 0;\n  }\n} else if (runMode === 'external_trigger') {\n  if (externalTrigger === true && (internalState.prevExtTriggerState === false || internalState.prevExtTriggerState === undefined)) {\n    stepAutomaton();\n  }\n}\ninternalState.timeSinceLastInternalStep = timeSinceLastInternalStep;\ninternalState.prevExtTriggerState = externalTrigger;\n\nreturn internalState;","initialPrompt":"Create a Rule 110 cellular automaton block. Parameters: \"Core Length\" (slider 1-16), \"Pattern + Boundaries\" (step_sequencer_ui, 18 steps for L-Bnd, N core, R-Bnd), \"Run Mode\" (select: Internal Trigger, External Trigger, LFO), \"Internal Freq (Hz)\" (number_input 0.01-8000), \"LFO BPM Sync Rate\" (select), \"LFO Sync to BPM\" (toggle). Inputs: \"Trigger\", \"Numeric State In\". Output: \"Numeric State Out\". Logic must implement Rule 110, handle timing for different modes, and convert core pattern to/from number. Max 16 core cells + 2 boundaries = 18 UI steps.","isAiGenerated":false},{"id":"rule-110-oscillator-v1","name":"Rule 110 Oscillator","description":"Oscillator using Rule 110 automaton for sound generation via AudioWorklet. CV input controls Rule 110 update rate.","runsAtAudioRate":true,"inputs":[{"id":"rate_cv_in","name":"Rate CV","type":"audio","description":"Controls update rate of the Rule 110 automaton (higher CV = faster updates)."}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"Generated audio signal from the automaton."}],"parameters":[{"id":"core_length","name":"Core Length (N)","type":"slider","defaultValue":8,"min":1,"max":16,"step":1,"description":"Number of core cells for the automaton."},{"id":"initial_pattern_plus_boundaries","name":"Pattern + Boundaries","type":"step_sequencer_ui","defaultValue":[false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],"description":"Initial state including boundaries.","steps":18},{"id":"base_update_rate_hz","name":"Base Update Rate (Hz)","type":"slider","defaultValue":440,"min":1,"max":20000,"step":1,"description":"Base internal update frequency of the Rule 110 automaton.","isFrequency":true},{"id":"cv_sensitivity","name":"CV Sensitivity","type":"slider","defaultValue":1000,"min":0,"max":5000,"step":1,"description":"Multiplier for rate_cv_in to modulate update rate."},{"id":"output_mode","name":"Output Mode","type":"select","defaultValue":"sum_bits","options":[{"value":"sum_bits","label":"Sum Bits"},{"value":"center_bit","label":"Center Bit"}],"description":"Method to generate audio sample from pattern."},{"id":"gain","name":"Gain","type":"slider","defaultValue":0.5,"min":0,"max":1,"step":0.01,"description":"Output amplitude (controls AudioParam in worklet)."}],"logicCode":"// Main thread logic for Rule 110 Oscillator\nconst baseRateHz = params.base_update_rate_hz;\nconst cvSensitivity = params.cv_sensitivity;\nconst rateCV = inputs.rate_cv_in; // Expected to be audio-rate, effectively 0 if not connected.\n\n// Rate CV is audio, typically -1 to 1. We want it to modulate positively around baseRate.\n// Map CV from [-1, 1] to a multiplier, e.g., [0.1, 10] or similar.\n// Let's say CV of 0 means base rate. CV of 1 means baseRate + cvSensitivity. CV of -1 means baseRate - cvSensitivity (clamped).\n// A simpler approach for audio CV: treat it as a direct addition to frequency, scaled by sensitivity.\n// If rateCV is an audio signal, it will average to 0 over time if not DC biased.\n// For this example, let's assume host ensures rateCV is a somewhat stable value if connected to LFO, etc.\n// Average of audio signal is 0, so let's use it as deviation.\n// Effective rate = baseRate + (rateCV * cvSensitivity)\n// This is tricky if rateCV is full audio. For now, let's assume it provides a control value.\n// If rateCV input is not connected, inputs.rate_cv_in will be 0.\nconst modulatedRateHz = Math.max(1, baseRateHz + (rateCV * cvSensitivity)); // Ensure positive rate\n\nconst sampleRate = audioContextInfo ? audioContextInfo.sampleRate : 44100;\nconst samplesPerRuleStep = Math.max(1, Math.round(sampleRate / modulatedRateHz));\n\nif (postMessageToWorklet) {\n  if (internalState.lastSamplesPerRuleStep !== samplesPerRuleStep) {\n    postMessageToWorklet({ type: 'SET_SAMPLES_PER_RULE_STEP', value: samplesPerRuleStep });\n    internalState.lastSamplesPerRuleStep = samplesPerRuleStep;\n    // __custom_block_logger__(`Rule110Osc: Samples per step set to ${samplesPerRuleStep} (Rate: ${modulatedRateHz.toFixed(2)} Hz)`);\n  }\n  \n  const currentPattern = params.initial_pattern_plus_boundaries;\n  if (JSON.stringify(internalState.lastPatternSent) !== JSON.stringify(currentPattern)) {\n    postMessageToWorklet({ type: 'SET_PATTERN', pattern: currentPattern });\n    internalState.lastPatternSent = [...currentPattern];\n  }\n  \n  const coreLength = params.core_length;\n  if (internalState.lastCoreLength !== coreLength) {\n    postMessageToWorklet({ type: 'SET_CORE_LENGTH', coreLength: coreLength, fullPatternAfterResize: currentPattern });\n    internalState.lastCoreLength = coreLength;\n     __custom_block_logger__(`Rule110Osc: Core length changed to ${coreLength}. Pattern may need UI refresh.`);\n  }\n\n  const outputMode = params.output_mode;\n  if (internalState.lastOutputMode !== outputMode) {\n    postMessageToWorklet({ type: 'SET_OUTPUT_MODE', outputMode: outputMode });\n    internalState.lastOutputMode = outputMode;\n  }\n}\n// Gain is handled by AudioParam in worklet, host updates it from params.gain\n\nreturn internalState;","initialPrompt":"Create a Rule 110 Oscillator. It uses a Rule 110 automaton in an AudioWorklet. Parameters: \"Core Length\", \"Pattern + Boundaries\", \"Base Update Rate (Hz)\", \"CV Sensitivity\", \"Output Mode\" (Sum Bits/Center Bit), \"Gain\". Inputs: \"Rate CV\" (audio). Output: \"Audio Output\". Logic code sends params to worklet. Worklet runs automaton, generates audio based on selected mode and pattern state, modulated by CV.","audioWorkletProcessorName":"rule-110-oscillator-processor","audioWorkletCode":"\n// Rule 110 Oscillator Worklet Processor\nclass Rule110OscillatorProcessor extends AudioWorkletProcessor {\n  static get parameterDescriptors() {\n    return [\n      { name: 'gain', defaultValue: 1, minValue: 0, maxValue: 10, automationRate: 'a-rate' },\n      // Frequency is controlled by sample rate (CV into logic) and internal rule 110 speed.\n      // The worklet itself doesn't have a frequency AudioParam directly tied to pitch.\n    ];\n  }\n\n  constructor(options) {\n    super(options);\n    this.coreLength = options?.processorOptions?.coreLength || 8;\n    this.outputMode = options?.processorOptions?.outputMode || 'sum_bits'; // 'sum_bits' or 'center_bit'\n    \n    // Initialize pattern: L-Boundary + Core + R-Boundary\n    this.totalPatternLength = this.coreLength + 2;\n    this.pattern = new Array(this.totalPatternLength).fill(false);\n    const initialPatternParam = options?.processorOptions?.initialPattern || [];\n    for(let i=0; i < Math.min(this.totalPatternLength, initialPatternParam.length); ++i) {\n      this.pattern[i] = initialPatternParam[i] === true;\n    }\n\n    this.samplesSinceLastStep = 0;\n    this.samplesPerRuleStep = options?.processorOptions?.samplesPerRuleStep || Math.round(sampleRate / 100); // Default 100 Hz update for Rule 110\n    \n    this.RULE_110_MAP = [0,1,1,1,0,1,1,0]; // For 111 to 000\n\n    this.port.onmessage = (event) => {\n      if (event.data?.type === 'SET_SAMPLES_PER_RULE_STEP') {\n        this.samplesPerRuleStep = Math.max(1, Math.round(event.data.value));\n      }\n      if (event.data?.type === 'SET_PATTERN') {\n         const newPatternArray = event.data.pattern; // Should be boolean array\n         if (Array.isArray(newPatternArray) && newPatternArray.length === this.totalPatternLength) {\n           this.pattern = [...newPatternArray];\n         }\n      }\n      if (event.data?.type === 'SET_CORE_LENGTH') {\n        this.coreLength = event.data.coreLength;\n        this.totalPatternLength = this.coreLength + 2;\n        // Re-initialize pattern based on new coreLength, possibly from a new full pattern if sent\n        const currentFullPattern = event.data.fullPatternAfterResize || []; // Assume host sends adjusted pattern\n        this.pattern = new Array(this.totalPatternLength).fill(false);\n        for(let i=0; i < Math.min(this.totalPatternLength, currentFullPattern.length); ++i) {\n          this.pattern[i] = currentFullPattern[i] === true;\n        }\n      }\n       if (event.data?.type === 'SET_OUTPUT_MODE') {\n        this.outputMode = event.data.outputMode;\n      }\n    };\n  }\n\n  applyRule110(left, middle, right) {\n    const index = (left ? 4 : 0) + (middle ? 2 : 0) + (right ? 1 : 0);\n    return this.RULE_110_MAP[index] === 1;\n  }\n\n  stepAutomaton() {\n    const nextPattern = [...this.pattern];\n    for (let i = 0; i < this.coreLength; ++i) {\n      const leftNeighbor = this.pattern[i];\n      const currentCell  = this.pattern[i + 1];\n      const rightNeighbor= this.pattern[i + 2];\n      nextPattern[i + 1] = this.applyRule110(leftNeighbor, currentCell, rightNeighbor);\n    }\n    this.pattern = nextPattern;\n  }\n\n  getOutputSample() {\n    if (this.outputMode === 'center_bit') {\n      const centerIndex = Math.floor(this.coreLength / 2) + 1; // +1 for L-Boundary offset\n      return this.pattern[centerIndex] ? 1.0 : -1.0;\n    } else { // 'sum_bits' (default)\n      let sum = 0;\n      for (let i = 0; i < this.coreLength; ++i) {\n        if (this.pattern[i + 1]) { // Core cells are from index 1 to coreLength\n          sum++;\n        }\n      }\n      // Normalize sum to -1 to 1 range. Max sum is coreLength.\n      if (this.coreLength === 0) return 0;\n      return (sum / this.coreLength) * 2.0 - 1.0;\n    }\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannel = output[0];\n    const gainValues = parameters.gain;\n\n    for (let i = 0; i < outputChannel.length; ++i) {\n      if (this.samplesSinceLastStep >= this.samplesPerRuleStep) {\n        this.stepAutomaton();\n        this.samplesSinceLastStep = 0;\n      }\n      const gain = gainValues.length > 1 ? gainValues[i] : gainValues[0];\n      outputChannel[i] = this.getOutputSample() * gain;\n      this.samplesSinceLastStep++;\n    }\n    return true;\n  }\n}\n","isAiGenerated":false},{"id":"rule-110-join-v1","name":"Rule 110 Join","description":"Joins two numeric states for a Rule 110 automaton, computes next step, splits, and outputs.","inputs":[{"id":"numeric_state_in_1","name":"Numeric State In 1","type":"number","description":"First part of the automaton state."},{"id":"numeric_state_in_2","name":"Numeric State In 2","type":"number","description":"Second part of the automaton state."},{"id":"trigger_in","name":"Trigger","type":"trigger","description":"Advances automaton one step."}],"outputs":[{"id":"numeric_state_out_1","name":"Numeric State Out 1","type":"number","description":"First part of the next state."},{"id":"numeric_state_out_2","name":"Numeric State Out 2","type":"number","description":"Second part of the next state."}],"parameters":[{"id":"core_length_1","name":"Core Length 1 (N1)","type":"slider","defaultValue":4,"min":1,"max":8,"step":1,"description":"Number of bits for state 1."},{"id":"core_length_2","name":"Core Length 2 (N2)","type":"slider","defaultValue":4,"min":1,"max":8,"step":1,"description":"Number of bits for state 2."},{"id":"boundary_bits_handling","name":"Boundary Bits","type":"select","defaultValue":"zero","options":[{"value":"zero","label":"Zeros"},{"value":"one","label":"Ones"},{"value":"wrap","label":"Wrap Around"}],"description":"How to handle boundary bits for the combined automaton."}],"logicCode":"const N1 = Math.max(1, Math.min(8, params.core_length_1));\nconst N2 = Math.max(1, Math.min(8, params.core_length_2));\nconst totalCoreLength = N1 + N2;\n\nconst stateIn1 = inputs.numeric_state_in_1;\nconst stateIn2 = inputs.numeric_state_in_2;\nconst trigger = inputs.trigger_in;\n\nconst RULE_110_MAP = [0,1,1,1,0,1,1,0];\n\nfunction applyRule110(left, middle, right) {\n  const index = (left ? 4 : 0) + (middle ? 2 : 0) + (right ? 1 : 0);\n  return RULE_110_MAP[index] === 1;\n}\n\n// Initialize pattern if not present or if lengths changed\nif (!internalState.currentPattern || internalState.N1 !== N1 || internalState.N2 !== N2) {\n  internalState.currentPattern = new Array(totalCoreLength + 2).fill(false); // +2 for L/R boundaries\n  internalState.N1 = N1;\n  internalState.N2 = N2;\n   __custom_block_logger__(`Pattern re-initialized for N1=${N1}, N2=${N2}`);\n}\nlet currentPattern = internalState.currentPattern;\n\n// Apply inputs to pattern if available\nif (stateIn1 !== null && typeof stateIn1 === 'number') {\n  const maxVal1 = (1 << N1) - 1;\n  const intVal1 = Math.max(0, Math.min(maxVal1, Math.floor(stateIn1)));\n  for (let i = 0; i < N1; i++) {\n    currentPattern[i + 1] = (intVal1 & (1 << (N1 - 1 - i))) !== 0; // Bit 0 of stateIn1 is MSB of N1 part\n  }\n}\nif (stateIn2 !== null && typeof stateIn2 === 'number') {\n  const maxVal2 = (1 << N2) - 1;\n  const intVal2 = Math.max(0, Math.min(maxVal2, Math.floor(stateIn2)));\n  for (let i = 0; i < N2; i++) {\n    currentPattern[N1 + i + 1] = (intVal2 & (1 << (N2 - 1 - i))) !== 0; // Bit 0 of stateIn2 is MSB of N2 part\n  }\n}\n\nif (trigger === true && (internalState.prevTriggerState === false || internalState.prevTriggerState === undefined)) {\n  const boundaryMode = params.boundary_bits_handling;\n  // Set boundary bits before stepping\n  if (boundaryMode === 'zero') {\n    currentPattern[0] = false; // Left boundary\n    currentPattern[totalCoreLength + 1] = false; // Right boundary\n  } else if (boundaryMode === 'one') {\n    currentPattern[0] = true;\n    currentPattern[totalCoreLength + 1] = true;\n  } else { // wrap\n    currentPattern[0] = currentPattern[totalCoreLength]; // L-bnd = last core cell of combined\n    currentPattern[totalCoreLength + 1] = currentPattern[1]; // R-bnd = first core cell of combined\n  }\n  \n  const nextPattern = [...currentPattern];\n  for (let i = 0; i < totalCoreLength; ++i) { // Iterate all core cells (N1+N2)\n    const leftNeighbor = currentPattern[i];\n    const currentCell  = currentPattern[i + 1];\n    const rightNeighbor= currentPattern[i + 2];\n    nextPattern[i + 1] = applyRule110(leftNeighbor, currentCell, rightNeighbor);\n  }\n  currentPattern = nextPattern;\n  internalState.currentPattern = currentPattern;\n\n  let numericOutput1 = 0;\n  for (let i = 0; i < N1; ++i) {\n    if (currentPattern[i + 1]) {\n      numericOutput1 |= (1 << (N1 - 1 - i));\n    }\n  }\n  setOutput('numeric_state_out_1', numericOutput1);\n\n  let numericOutput2 = 0;\n  for (let i = 0; i < N2; ++i) {\n    if (currentPattern[N1 + i + 1]) {\n      numericOutput2 |= (1 << (N2 - 1 - i));\n    }\n  }\n  setOutput('numeric_state_out_2', numericOutput2);\n  // __custom_block_logger__(`Join: Stepped. Out1: ${numericOutput1}, Out2: ${numericOutput2}`);\n}\ninternalState.prevTriggerState = trigger;\n\nreturn internalState;","initialPrompt":"Create a Rule 110 Join block. Parameters: \"Core Length 1 (N1)\" (slider 1-8), \"Core Length 2 (N2)\" (slider 1-8), \"Boundary Bits\" (select: Zeros, Ones, Wrap). Inputs: \"Numeric State In 1\", \"Numeric State In 2\", \"Trigger\". Outputs: \"Numeric State Out 1\", \"Numeric State Out 2\". Logic combines N1 and N2 bits, applies Rule 110 with chosen boundaries, then splits the result.","isAiGenerated":false},{"id":"rule-110-byte-reader-v1","name":"Rule 110 Byte Reader","description":"Reads a specific bit from incoming Rule 110 numeric states over N triggers, then outputs the collected byte (as number) and the chosen bit's last state.","inputs":[{"id":"numeric_state_in","name":"Numeric State In","type":"number","description":"Input from a Rule 110 source."},{"id":"trigger_in","name":"Trigger","type":"trigger","description":"Reads one bit on trigger."}],"outputs":[{"id":"byte_out","name":"Byte Out","type":"number","description":"Collected byte (8 bits) as a number, MSB first. Outputs when N bits are collected."},{"id":"selected_bit_out","name":"Selected Bit Out","type":"boolean","description":"State of the chosen bit from the last read numeric state."}],"parameters":[{"id":"rule110_core_length","name":"Input Core Length","type":"slider","defaultValue":8,"min":1,"max":16,"step":1,"description":"Core length of the Rule 110 source this block reads from."},{"id":"bit_to_read","name":"Bit to Read (0-indexed from MSB)","type":"slider","defaultValue":0,"min":0,"max":15,"step":1,"description":"Which bit of the input state to sample (0 is MSB)."},{"id":"bits_to_collect_N","name":"Bits to Collect (N)","type":"slider","defaultValue":8,"min":1,"max":8,"step":1,"description":"Number of bits to collect before outputting byte_out."}],"logicCode":"const coreLength = params.rule110_core_length;\nconst bitToRead = Math.min(params.bit_to_read, coreLength - 1); // Ensure bit_to_read is within coreLength\nconst N = params.bits_to_collect_N;\n\nconst numericStateIn = inputs.numeric_state_in;\nconst trigger = inputs.trigger_in;\n\nlet collectedBits = internalState.collectedBits || 0;\nlet bitCount = internalState.bitCount || 0;\nlet lastSelectedBitState = internalState.lastSelectedBitState || false;\n\nif (trigger === true && (internalState.prevTriggerState === false || internalState.prevTriggerState === undefined)) {\n  if (numericStateIn !== null && typeof numericStateIn === 'number' && isFinite(numericStateIn)) {\n    // Extract the specified bit (0-indexed from MSB)\n    // (numericStateIn >> (coreLength - 1 - bitToRead)) & 1\n    const selectedBit = ( (Math.floor(numericStateIn) >> (coreLength - 1 - bitToRead)) & 1 ) === 1;\n    lastSelectedBitState = selectedBit;\n    \n    collectedBits = (collectedBits << 1) | (selectedBit ? 1 : 0);\n    bitCount++;\n    \n    // __custom_block_logger__(`Read bit ${bitToRead} as ${selectedBit}. Collected: ${collectedBits.toString(2).padStart(bitCount,'0')}, Count: ${bitCount}/${N}`);\n\n    if (bitCount >= N) {\n      setOutput('byte_out', collectedBits & ((1 << N) -1) ); // Output last N bits\n      // __custom_block_logger__(`Byte output: ${collectedBits & ((1 << N) -1)} after ${N} bits.`);\n      collectedBits = 0; // Reset for next byte\n      bitCount = 0;\n    } else {\n      setOutput('byte_out', null); // No full byte yet\n    }\n  }\n}\nsetOutput('selected_bit_out', lastSelectedBitState);\n\ninternalState.collectedBits = collectedBits;\ninternalState.bitCount = bitCount;\ninternalState.lastSelectedBitState = lastSelectedBitState;\ninternalState.prevTriggerState = trigger;\n\nreturn internalState;","initialPrompt":"Create a Rule 110 Byte Reader. Parameters: \"Input Core Length\" (slider 1-16), \"Bit to Read (0-indexed from MSB)\" (slider 0-15), \"Bits to Collect (N)\" (slider 1-8 for byte). Inputs: \"Numeric State In\", \"Trigger\". Outputs: \"Byte Out\" (number, after N bits), \"Selected Bit Out\" (boolean). Logic samples the chosen bit from input on trigger, accumulates N bits, then outputs byte.","isAiGenerated":false},{"id":"byte-reverse-v1","name":"Byte Reverse","description":"Reverses the order of N bits in an incoming number.","inputs":[{"id":"number_in","name":"Number In","type":"number","description":"Integer number to process."}],"outputs":[{"id":"reversed_number_out","name":"Reversed Number Out","type":"number","description":"Number with N LSBs reversed."}],"parameters":[{"id":"num_bits_N","name":"Number of Bits (N)","type":"slider","defaultValue":8,"min":1,"max":16,"step":1,"description":"Number of LSBs to consider for reversal."}],"logicCode":"const numberIn = inputs.number_in;\nconst N = params.num_bits_N;\nlet reversedNum = 0;\n\nif (numberIn !== null && typeof numberIn === 'number' && isFinite(numberIn)) {\n  const val = Math.floor(Math.abs(numberIn)); // Use positive integer part\n  for (let i = 0; i < N; i++) {\n    if ((val >> i) & 1) { // Check i-th LSB of input\n      reversedNum |= (1 << (N - 1 - i)); // Set (N-1-i)-th LSB of output\n    }\n  }\n  // __custom_block_logger__(`Reversed ${val} (N=${N}) to ${reversedNum}`);\n  setOutput('reversed_number_out', reversedNum);\n} else {\n  setOutput('reversed_number_out', 0); // Default if no valid input\n}\nreturn {};","initialPrompt":"Create a Byte Reverse block. Parameter: \"Number of Bits (N)\" (slider 1-16, default 8). Input: \"Number In\". Output: \"Reversed Number Out\". Logic reverses the order of the N least significant bits of the input number.","isAiGenerated":false},{"id":"lyria-realtime-master-v1","name":"Lyria Realtime Master","description":"Generates music in real-time using Lyria. Audio output is handled by the integrated LiveMusicService.","runsAtAudioRate":true,"inputs":[{"id":"scale_cv_in","name":"Scale CV","type":"any","description":"Modulates Lyria Scale (expects string matching GenAIScale value)"},{"id":"brightness_cv_in","name":"Brightness CV","type":"number","description":"Modulates Lyria Brightness (0-1)"},{"id":"density_cv_in","name":"Density CV","type":"number","description":"Modulates Lyria Density (0-1)"},{"id":"seed_cv_in","name":"Seed CV","type":"number","description":"Modulates Lyria Seed (integer)"},{"id":"temperature_cv_in","name":"Temperature CV","type":"number","description":"Modulates Lyria Temperature (e.g., 0.1-2.0)"},{"id":"guidance_cv_in","name":"Guidance CV","type":"number","description":"Modulates Lyria Guidance Scale (e.g., 1-20)"},{"id":"top_k_cv_in","name":"TopK CV","type":"number","description":"Modulates Lyria TopK (integer > 0)"},{"id":"bpm_cv_in","name":"BPM CV","type":"number","description":"Modulates Lyria BPM (e.g. 60-180)"},{"id":"play_gate_in","name":"Play Gate","type":"gate","description":"Gate for session.play() (high) / session.pause() (low)"},{"id":"stop_trigger_in","name":"Stop Trigger","type":"trigger","description":"Trigger for session.stop() and reset"},{"id":"reconnect_trigger_in","name":"Reconnect Trigger","type":"trigger","description":"Trigger to reconnect the Lyria session"},{"id":"mute_bass_gate_in","name":"Mute Bass Gate","type":"gate","description":"Gate to mute bass track"},{"id":"mute_drums_gate_in","name":"Mute Drums Gate","type":"gate","description":"Gate to mute drums track"},{"id":"only_bass_drums_gate_in","name":"Only Bass & Drums Gate","type":"gate","description":"Gate to solo bass & drums"},{"id":"prompts_in","name":"Prompts In","type":"any","description":"Array of Lyria WeightedPrompt objects [{text: string, weight: number}]"}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"Generated audio from Lyria LiveMusicService."}],"parameters":[{"id":"initial_prompt_text","name":"Initial Prompt Text","type":"text_input","defaultValue":"cinematic lofi hip hop","description":"Default text prompt for Lyria session."},{"id":"initial_prompt_weight","name":"Initial Prompt Weight","type":"slider","defaultValue":1,"min":0,"max":1,"step":0.01,"description":"Weight for initial prompt."},{"id":"scale","name":"Scale","type":"select","defaultValue":"C_MAJOR_A_MINOR","options":[{"label":"C MAJOR A MINOR","value":"C_MAJOR_A_MINOR"},{"label":"D MAJOR B MINOR","value":"D_MAJOR_B_MINOR"},{"label":"D # MAJOR C MINOR","value":"D_SHARP_MAJOR_C_MINOR"},{"label":"E MAJOR C # MINOR","value":"E_MAJOR_C_SHARP_MINOR"},{"label":"F MAJOR D MINOR","value":"F_MAJOR_D_MINOR"},{"label":"F # MAJOR D SHARP MINOR","value":"F_SHARP_MAJOR_D_SHARP_MINOR"},{"label":"G MAJOR E MINOR","value":"G_MAJOR_E_MINOR"},{"label":"G # MAJOR F MINOR","value":"G_SHARP_MAJOR_F_MINOR"},{"label":"A MAJOR F # MINOR","value":"A_MAJOR_F_SHARP_MINOR"},{"label":"A # MAJOR G MINOR","value":"A_SHARP_MAJOR_G_MINOR"},{"label":"B MAJOR G # MINOR","value":"B_MAJOR_G_SHARP_MINOR"}],"description":"Lyria Scale. Overridden by CV if connected."},{"id":"brightness","name":"Brightness","type":"slider","defaultValue":0.5,"min":0,"max":1,"step":0.01,"description":"Lyria Brightness (0-1). Overridden by CV."},{"id":"density","name":"Density","type":"slider","defaultValue":0.5,"min":0,"max":1,"step":0.01,"description":"Lyria Density (0-1). Overridden by CV."},{"id":"seed","name":"Seed","type":"number_input","defaultValue":0,"description":"Lyria Seed (0 for random date-based). Overridden by CV."},{"id":"temperature","name":"Temperature","type":"slider","defaultValue":1.1,"min":0.1,"max":2,"step":0.01,"description":"Lyria Temperature. Overridden by CV."},{"id":"guidance_scale","name":"Guidance Scale","type":"slider","defaultValue":7,"min":1,"max":20,"step":0.1,"description":"Lyria Guidance Scale. Overridden by CV."},{"id":"top_k","name":"Top K","type":"number_input","defaultValue":40,"min":1,"max":100,"step":1,"description":"Lyria Top K. Overridden by CV."},{"id":"bpm","name":"BPM","type":"number_input","defaultValue":120,"min":30,"max":240,"step":1,"description":"Lyria BPM. Overridden by CV."}],"logicCode":"// Lyria Realtime Master - Main Thread Logic\nlet newInternalState = { ...internalState };\n\n// --- Handle Config Parameter Changes (CV overrides params) ---\nconst configChanged = \n    params.scale !== internalState.lastScale ||\n    params.brightness !== internalState.lastBrightness ||\n    params.density !== internalState.lastDensity ||\n    params.seed !== internalState.lastSeed ||\n    params.temperature !== internalState.lastTemperature ||\n    params.guidance_scale !== internalState.lastGuidanceScale ||\n    params.top_k !== internalState.lastTopK ||\n    params.bpm !== internalState.lastBpm ||\n    inputs.scale_cv_in !== internalState.lastScaleCv ||\n    inputs.brightness_cv_in !== internalState.lastBrightnessCv ||\n    inputs.density_cv_in !== internalState.lastDensityCv ||\n    inputs.seed_cv_in !== internalState.lastSeedCv ||\n    inputs.temperature_cv_in !== internalState.lastTemperatureCv ||\n    inputs.guidance_cv_in !== internalState.lastGuidanceCv ||\n    inputs.top_k_cv_in !== internalState.lastTopKCv ||\n    inputs.bpm_cv_in !== internalState.lastBpmCv;\n\nif (configChanged) {\n    newInternalState.configUpdateNeeded = true;\n    newInternalState.lastScale = params.scale;\n    newInternalState.lastBrightness = params.brightness;\n    newInternalState.lastDensity = params.density;\n    newInternalState.lastSeed = params.seed;\n    newInternalState.lastTemperature = params.temperature;\n    newInternalState.lastGuidanceScale = params.guidance_scale;\n    newInternalState.lastTopK = params.top_k;\n    newInternalState.lastBpm = params.bpm;\n    newInternalState.lastScaleCv = inputs.scale_cv_in;\n    newInternalState.lastBrightnessCv = inputs.brightness_cv_in;\n    newInternalState.lastDensityCv = inputs.density_cv_in;\n    newInternalState.lastSeedCv = inputs.seed_cv_in;\n    newInternalState.lastTemperatureCv = inputs.temperature_cv_in;\n    newInternalState.lastGuidanceCv = inputs.guidance_cv_in;\n    newInternalState.lastTopKCv = inputs.top_k_cv_in;\n    newInternalState.lastBpmCv = inputs.bpm_cv_in;\n    __custom_block_logger__(\"Lyria config params or CV changed. Flagging for update.\");\n}\n\n\n// --- Handle Prompts ---\nconst promptsInput = inputs.prompts_in;\nconst initialPromptText = params.initial_prompt_text;\nconst initialPromptWeight = params.initial_prompt_weight;\nlet effectivePrompts = [];\nif (promptsInput && Array.isArray(promptsInput) && promptsInput.length > 0) {\n    effectivePrompts = promptsInput.filter(p => p && typeof p.text === 'string' && typeof p.weight === 'number');\n} else if (initialPromptText && initialPromptText.trim() !== \"\") {\n    effectivePrompts = [{ text: initialPromptText.trim(), weight: initialPromptWeight }];\n}\nif (JSON.stringify(effectivePrompts) !== JSON.stringify(internalState.lastEffectivePrompts)) {\n    newInternalState.promptsUpdateNeeded = true;\n    newInternalState.lastEffectivePrompts = effectivePrompts;\n     __custom_block_logger__(`Lyria prompts changed. Flagging for update. Num prompts: ${effectivePrompts.length}`);\n}\n\n// --- Handle Play/Pause/Stop/Reconnect/Restart ---\n// internalState.isPlaying is updated by App.tsx based on service feedback\n// internalState.wasPausedDueToGateLow helps gate logic avoid re-triggering play if already playing.\n\nconst playGate = !!inputs.play_gate_in;\nconst stopTrigger = inputs.stop_trigger_in;\nconst reconnectTrigger = inputs.reconnect_trigger_in;\nconst UIRestartRequest = internalState.restartRequest;\n\nif (UIRestartRequest) {\n    newInternalState.stopRequest = true;\n    newInternalState.playRequest = true;\n    newInternalState.pauseRequest = false;\n    newInternalState.restartRequest = false; // Consume UI request\n    newInternalState.wasPausedDueToGateLow = false; // Reset this on restart\n    __custom_block_logger__(\"UI Restart triggered. Requesting stop then play.\");\n} else if (stopTrigger && (internalState.prevStopTrigger === false || internalState.prevStopTrigger === undefined)) {\n    newInternalState.stopRequest = true;\n    newInternalState.playRequest = false;\n    newInternalState.pauseRequest = false;\n    newInternalState.wasPausedDueToGateLow = false; // Reset this on stop\n    __custom_block_logger__(\"Stop trigger received. Requesting stop.\");\n} else if (playGate) {\n    if (!internalState.isPlaying || internalState.wasPausedDueToGateLow) {\n        newInternalState.playRequest = true;\n        newInternalState.pauseRequest = false;\n        newInternalState.wasPausedDueToGateLow = false;\n        __custom_block_logger__(\"Play gate high. Requesting play.\");\n    }\n} else { // Play gate is low\n    if (internalState.isPlaying && !newInternalState.stopRequest && !newInternalState.playRequest) { // Only pause if playing and no other command active\n        newInternalState.pauseRequest = true;\n        newInternalState.playRequest = false;\n        newInternalState.wasPausedDueToGateLow = true;\n        __custom_block_logger__(\"Play gate low. Requesting pause.\");\n    }\n}\nnewInternalState.prevStopTrigger = stopTrigger;\n\nif (reconnectTrigger && (internalState.prevReconnectTrigger === false || internalState.prevReconnectTrigger === undefined)) {\n    newInternalState.reconnectRequest = true;\n    __custom_block_logger__(\"Reconnect trigger received. Requesting reconnect.\");\n}\nnewInternalState.prevReconnectTrigger = reconnectTrigger;\n\n\n// --- Handle Track Muting ---\nconst muteBassGate = !!inputs.mute_bass_gate_in;\nconst muteDrumsGate = !!inputs.mute_drums_gate_in;\nconst onlyBassDrumsGate = !!inputs.only_bass_drums_gate_in;\nif (muteBassGate !== internalState.lastMuteBass || \n    muteDrumsGate !== internalState.lastMuteDrums || \n    onlyBassDrumsGate !== internalState.lastOnlyBassDrums) {\n    newInternalState.trackMuteUpdateNeeded = true;\n    newInternalState.lastMuteBass = muteBassGate;\n    newInternalState.lastMuteDrums = muteDrumsGate;\n    newInternalState.lastOnlyBassDrums = onlyBassDrumsGate;\n    __custom_block_logger__(`Track mute states changed. Bass: ${muteBassGate}, Drums: ${muteDrumsGate}, OnlyBassDrums: ${onlyBassDrumsGate}`);\n}\n\nreturn newInternalState;","initialPrompt":"Create a Lyria Realtime Master block that interfaces with the LiveMusicService. It should manage playback (play, pause, stop, reconnect), prompts, and various music generation parameters (scale, brightness, density, seed, temperature, guidance, top_k, bpm) via inputs and parameters. Also include track muting controls (muteBass, muteDrums, onlyBassAndDrums). The block itself does not generate audio worklet code; it controls the service.","isAiGenerated":false},{"id":"lyria-realtime-prompt-v1","name":"Lyria Realtime Prompt","description":"Creates a single prompt object for Lyria with text and weight.","inputs":[{"id":"text_in","name":"Text In","type":"string","description":"Overrides prompt text parameter."},{"id":"weight_in","name":"Weight In","type":"number","description":"Overrides prompt weight parameter (0-1)."}],"outputs":[{"id":"prompt_out","name":"Prompt Object","type":"any","description":"{text: string, weight: number}"}],"parameters":[{"id":"prompt_text","name":"Prompt Text","type":"text_input","defaultValue":"","description":"Text content of the prompt."},{"id":"prompt_weight","name":"Weight","type":"slider","defaultValue":0.5,"min":0,"max":1,"step":0.01,"description":"Weight of the prompt (0.0 to 1.0)."}],"logicCode":"// Lyria Realtime Prompt Block Logic\nconst textParam = params.prompt_text;\nconst weightParam = params.prompt_weight;\n\nconst textInput = inputs.text_in;\nconst weightInput = inputs.weight_in; // number between 0 and 1\n\nconst effectiveText = (textInput !== null && textInput !== undefined && typeof textInput === 'string' && textInput.trim() !== \"\") ? textInput : textParam;\nlet effectiveWeight = weightParam;\n\nif (weightInput !== null && weightInput !== undefined && typeof weightInput === 'number' && !isNaN(weightInput)) {\n  effectiveWeight = Math.max(0, Math.min(1, weightInput)); // Clamp to 0-1\n}\n\nconst promptObject = {\n  text: effectiveText,\n  weight: effectiveWeight\n};\n\nsetOutput('prompt_out', promptObject);\n// __custom_block_logger__(`Lyria Prompt: ${JSON.stringify(promptObject)}`);\n\nreturn {};","initialPrompt":"Create a Lyria Realtime Prompt block. Inputs: text_in (string), weight_in (number 0-1). Outputs: prompt_out (any, for {text, weight} object). Parameters: \"Prompt Text\" (text_input), \"Prompt Weight\" (slider 0-1). Logic forms the output object from inputs or parameters.","isAiGenerated":false},{"id":"native-oscillator-v1","name":"Oscillator (Native)","description":"Generates a basic waveform using a native Web Audio API OscillatorNode and an internal GainNode for amplitude.","runsAtAudioRate":true,"inputs":[{"id":"freq_in","name":"Frequency CV","type":"audio","description":"Modulates OscillatorNode.frequency AudioParam directly.","audioParamTarget":"frequency"}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"The generated audio signal (from internal GainNode)."}],"parameters":[{"id":"frequency","name":"Frequency","type":"slider","defaultValue":440,"min":20,"max":5000,"step":1,"description":"Base frequency in Hz (OscillatorNode.frequency).","isFrequency":true},{"id":"waveform","name":"Waveform","type":"select","defaultValue":"sine","options":[{"value":"sine","label":"Sine"},{"value":"square","label":"Square"},{"value":"sawtooth","label":"Sawtooth"},{"value":"triangle","label":"Triangle"}],"description":"Shape of the waveform (OscillatorNode.type)."},{"id":"gain","name":"Gain/CV Depth","type":"slider","defaultValue":0.5,"min":0,"max":200,"step":0.1,"description":"Output amplitude or CV modulation depth. Controls an internal GainNode."}],"logicCode":"// This block is implemented natively by the browser (e.g., OscillatorNode, BiquadFilterNode, DelayNode, AnalyserNode, ConstantSourceNode).\n// Its AudioParams and properties are controlled by the audio engine (useAudioEngine.ts) based on UI changes ('params') and connected inputs (passed to engine).\n// This main-thread 'logicCode' does not process or output audio. 'inputs.audio_in' will be null.\n// Audio connections ('audio_in', 'audio_out', CV inputs) are part of the Web Audio API graph, managed by the host.\n// The 'audioContextInfo' object in scope may contain { sampleRate: number, bpm: number }.\n// __custom_block_logger__('Native Block: Main-thread tick. Parameters for the native AudioNode are managed by the host audio engine.');\nreturn {}; // No internal state change by default.","initialPrompt":"Create an audio oscillator block using a native Web Audio API OscillatorNode. It should have frequency, waveform type (sine, square, sawtooth, triangle), and gain parameters. The gain should control an internal GainNode. It needs an audio input for frequency CV. No trigger input for phase reset.","isAiGenerated":false},{"id":"native-biquad-filter-v1","name":"Biquad Filter (Native)","description":"A standard Web Audio API BiquadFilterNode. Parameters control the underlying native node. Audio path is managed by Web Audio graph connections.","runsAtAudioRate":true,"inputs":[{"id":"audio_in","name":"Audio Input","type":"audio","description":"Connects to native BiquadFilterNode input in Web Audio graph."},{"id":"freq_cv_in","name":"Freq CV","type":"audio","description":"Modulates frequency AudioParam directly in Web Audio graph.","audioParamTarget":"frequency"},{"id":"q_cv_in","name":"Q CV","type":"audio","description":"Modulates Q AudioParam directly in Web Audio graph.","audioParamTarget":"Q"}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"Output from native BiquadFilterNode in Web Audio graph."}],"parameters":[{"id":"frequency","name":"Frequency","type":"slider","defaultValue":350,"min":20,"max":20000,"step":1,"description":"Filter cutoff/center frequency in Hz (AudioParam).","isFrequency":true},{"id":"q","name":"Q Factor","type":"slider","defaultValue":1,"min":0.0001,"max":1000,"step":0.0001,"description":"Quality factor, controlling bandwidth (AudioParam)."},{"id":"gain","name":"Gain (dB)","type":"slider","defaultValue":0,"min":-40,"max":40,"step":0.1,"description":"Gain in decibels, for Peaking, Lowshelf, Highshelf (AudioParam)."},{"id":"type","name":"Filter Type","type":"select","defaultValue":"lowpass","options":[{"value":"lowpass","label":"Lowpass"},{"value":"highpass","label":"Highpass"},{"value":"bandpass","label":"Bandpass"},{"value":"notch","label":"Notch"},{"value":"allpass","label":"Allpass"},{"value":"peaking","label":"Peaking"},{"value":"lowshelf","label":"Lowshelf"},{"value":"highshelf","label":"Highshelf"}],"description":"The type of filtering algorithm (native node property)."}],"logicCode":"// This block is implemented natively by the browser (e.g., OscillatorNode, BiquadFilterNode, DelayNode, AnalyserNode, ConstantSourceNode).\n// Its AudioParams and properties are controlled by the audio engine (useAudioEngine.ts) based on UI changes ('params') and connected inputs (passed to engine).\n// This main-thread 'logicCode' does not process or output audio. 'inputs.audio_in' will be null.\n// Audio connections ('audio_in', 'audio_out', CV inputs) are part of the Web Audio API graph, managed by the host.\n// The 'audioContextInfo' object in scope may contain { sampleRate: number, bpm: number }.\n// __custom_block_logger__('Native Block: Main-thread tick. Parameters for the native AudioNode are managed by the host audio engine.');\nreturn {}; // No internal state change by default.","initialPrompt":"Standard Web Audio API BiquadFilterNode. Its parameters (frequency, Q, gain, type) should control the corresponding AudioParams/properties on the native node. It should have audio inputs for the main signal and for frequency/Q CV modulation.","logicCodeTests":"describe('NativeBiquadFilter LogicCode Placeholder Tests', () => {\n  it('should run without error and produce no output by default', async (context) => {\n    context.resetTestContext();\n    // Inputs to logicCode are for main-thread control, not direct audio samples for native node.\n    const inputs = { audio_in: null, freq_cv_in: null, q_cv_in: null };\n    const params = { frequency: 1000, q: 1, gain: 0, type: 'lowpass' };\n    const resultState = context.TestedLogic(inputs, params, {});\n    const outputs = context.getOutputs();\n    expect(Object.keys(outputs).length).toBe(0); // NATIVE_LOGIC_CODE_PLACEHOLDER does not call setOutput.\n    expect(resultState).toEqual({});\n  });\n});","isAiGenerated":false},{"id":"native-delay-v1","name":"Delay (Native)","description":"A standard Web Audio API DelayNode. Audio path is managed by Web Audio graph connections.","runsAtAudioRate":true,"inputs":[{"id":"audio_in","name":"Audio Input","type":"audio","description":"Connects to native DelayNode input in Web Audio graph."},{"id":"delay_cv_in","name":"Delay CV","type":"audio","description":"Modulates delayTime AudioParam directly in Web Audio graph.","audioParamTarget":"delayTime"}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"Output from native DelayNode in Web Audio graph."}],"parameters":[{"id":"delayTime","name":"Delay Time (s)","type":"slider","defaultValue":0.5,"min":0,"max":5,"step":0.001,"description":"Delay in seconds (AudioParam). Max effective delay fixed at node creation (e.g. 5s by default in engine)."}],"logicCode":"// This block is implemented natively by the browser (e.g., OscillatorNode, BiquadFilterNode, DelayNode, AnalyserNode, ConstantSourceNode).\n// Its AudioParams and properties are controlled by the audio engine (useAudioEngine.ts) based on UI changes ('params') and connected inputs (passed to engine).\n// This main-thread 'logicCode' does not process or output audio. 'inputs.audio_in' will be null.\n// Audio connections ('audio_in', 'audio_out', CV inputs) are part of the Web Audio API graph, managed by the host.\n// The 'audioContextInfo' object in scope may contain { sampleRate: number, bpm: number }.\n// __custom_block_logger__('Native Block: Main-thread tick. Parameters for the native AudioNode are managed by the host audio engine.');\nreturn {}; // No internal state change by default.","initialPrompt":"Standard Web Audio API DelayNode with a delayTime parameter. It should accept audio input for the main signal and CV for delayTime modulation.","isAiGenerated":false},{"id":"native-allpass-filter-v1","name":"Allpass Filter (Native)","description":"A native allpass filter. Implements y[n] = -g*x[n] + x[n-M] + g*y[n-M] using DelayNodes and GainNodes.","runsAtAudioRate":true,"inputs":[{"id":"audio_in","name":"Audio Input","type":"audio","description":"Signal to process."},{"id":"delay_cv_in","name":"Delay CV","type":"audio","description":"Modulates the delay time of the main input delay path.","audioParamTarget":"delayTime"},{"id":"coeff_cv_in","name":"Coeff CV","type":"audio","description":"Modulates the 'g' coefficient of the feedback path.","audioParamTarget":"coefficient"}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"Processed audio signal."}],"parameters":[{"id":"delayTime","name":"Delay Time (s)","type":"slider","defaultValue":0.05,"min":0.0001,"max":1,"step":0.0001,"description":"Delay length M in seconds. Affects both input and feedback delay paths."},{"id":"coefficient","name":"Coefficient (g)","type":"slider","defaultValue":0.5,"min":-0.99,"max":0.99,"step":0.01,"description":"Feedback/feedforward coefficient g."}],"logicCode":"// This block is implemented natively by the browser (e.g., OscillatorNode, BiquadFilterNode, DelayNode, AnalyserNode, ConstantSourceNode).\n// Its AudioParams and properties are controlled by the audio engine (useAudioEngine.ts) based on UI changes ('params') and connected inputs (passed to engine).\n// This main-thread 'logicCode' does not process or output audio. 'inputs.audio_in' will be null.\n// Audio connections ('audio_in', 'audio_out', CV inputs) are part of the Web Audio API graph, managed by the host.\n// The 'audioContextInfo' object in scope may contain { sampleRate: number, bpm: number }.\n// __custom_block_logger__('Native Block: Main-thread tick. Parameters for the native AudioNode are managed by the host audio engine.');\nreturn {}; // No internal state change by default.","initialPrompt":"Create a native allpass filter using DelayNodes and GainNodes to implement the structure y[n] = -g*x[n] + x[n-M] + g*y[n-M]. Parameters: delayTime (M), coefficient (g). Add CV inputs for delayTime (targeting the input delay path) and coefficient (targeting the feedback gain).","isAiGenerated":false},{"id":"analyser-oscilloscope-v1","name":"Oscilloscope (Analyser)","description":"Visualizes an audio signal waveform using a native AnalyserNode. The UI is shown in the block detail panel.","runsAtAudioRate":true,"inputs":[{"id":"audio_in","name":"Audio Input","type":"audio","description":"Signal to visualize."}],"outputs":[],"parameters":[{"id":"fftSize","name":"FFT Size","type":"select","defaultValue":2048,"options":[{"value":32,"label":"32"},{"value":64,"label":"64"},{"value":128,"label":"128"},{"value":256,"label":"256"},{"value":512,"label":"512"},{"value":1024,"label":"1024"},{"value":2048,"label":"2048"},{"value":4096,"label":"4096"},{"value":8192,"label":"8192"},{"value":16384,"label":"16384"},{"value":32768,"label":"32768"}],"description":"Size of the FFT window. This influences the detail in the time domain data for the oscilloscope."}],"logicCode":"// This block is implemented natively by the browser (e.g., OscillatorNode, BiquadFilterNode, DelayNode, AnalyserNode, ConstantSourceNode).\n// Its AudioParams and properties are controlled by the audio engine (useAudioEngine.ts) based on UI changes ('params') and connected inputs (passed to engine).\n// This main-thread 'logicCode' does not process or output audio. 'inputs.audio_in' will be null.\n// Audio connections ('audio_in', 'audio_out', CV inputs) are part of the Web Audio API graph, managed by the host.\n// The 'audioContextInfo' object in scope may contain { sampleRate: number, bpm: number }.\n// __custom_block_logger__('Native Block: Main-thread tick. Parameters for the native AudioNode are managed by the host audio engine.');\nreturn {}; // No internal state change by default.","initialPrompt":"Create an oscilloscope block using a native Web Audio AnalyserNode. It should take one audio input. It will have one parameter \"fftSize\" (select type, with power-of-2 options from 32 to 32768, default 2048) to control the AnalyserNode.fftSize property. The UI display for this block will be handled by a custom component in the detail panel.","isAiGenerated":false},{"id":"native-lfo-v1","name":"LFO (Native)","description":"Low-Frequency Oscillator using a native OscillatorNode. Max frequency 200Hz. Outputs an audio-rate signal, typically used for modulation.","runsAtAudioRate":true,"inputs":[{"id":"freq_cv_in","name":"Frequency CV","type":"audio","description":"Modulates LFO frequency.","audioParamTarget":"frequency"}],"outputs":[{"id":"audio_out","name":"LFO Output","type":"audio","description":"The LFO signal."}],"parameters":[{"id":"frequency","name":"Frequency (Hz)","type":"slider","defaultValue":1,"min":0.01,"max":200,"step":0.01,"description":"LFO frequency in Hz.","isFrequency":true},{"id":"waveform","name":"Waveform","type":"select","defaultValue":"sine","options":[{"value":"sine","label":"Sine"},{"value":"square","label":"Square"},{"value":"sawtooth","label":"Sawtooth"},{"value":"triangle","label":"Triangle"}],"description":"LFO waveform shape."},{"id":"gain","name":"Amplitude","type":"slider","defaultValue":1,"min":0,"max":10,"step":0.1,"description":"Amplitude of the LFO signal (controls internal GainNode)."}],"logicCode":"// This block is implemented natively by the browser (e.g., OscillatorNode, BiquadFilterNode, DelayNode, AnalyserNode, ConstantSourceNode).\n// Its AudioParams and properties are controlled by the audio engine (useAudioEngine.ts) based on UI changes ('params') and connected inputs (passed to engine).\n// This main-thread 'logicCode' does not process or output audio. 'inputs.audio_in' will be null.\n// Audio connections ('audio_in', 'audio_out', CV inputs) are part of the Web Audio API graph, managed by the host.\n// The 'audioContextInfo' object in scope may contain { sampleRate: number, bpm: number }.\n// __custom_block_logger__('Native Block: Main-thread tick. Parameters for the native AudioNode are managed by the host audio engine.');\nreturn {}; // No internal state change by default.","initialPrompt":"Create a native LFO block using an OscillatorNode. Max frequency 200Hz. Parameters: frequency (0.01-200Hz), waveform, amplitude. Input: frequency CV. Output: LFO audio signal.","isAiGenerated":false},{"id":"native-lfo-bpm-sync-v1","name":"LFO (BPM Sync)","description":"LFO synchronized to global BPM, using a native OscillatorNode. Frequency is derived from BPM and selected fraction.","runsAtAudioRate":true,"inputs":[],"outputs":[{"id":"audio_out","name":"LFO Output","type":"audio","description":"The BPM-synced LFO signal."}],"parameters":[{"id":"bpm_fraction","name":"BPM Fraction","type":"select","defaultValue":1,"options":[{"value":4,"label":"1 Bar (4/4)"},{"value":2,"label":"1/2 Note"},{"value":1.5,"label":"Dotted 1/4 Note"},{"value":1,"label":"1/4 Note (Beat)"},{"value":0.75,"label":"Dotted 1/8 Note"},{"value":0.5,"label":"1/8 Note"},{"value":0.3333333333333333,"label":"1/4 Triplet"},{"value":0.25,"label":"1/16 Note"},{"value":0.16666666666666666,"label":"1/8 Triplet"},{"value":0.125,"label":"1/32 Note"},{"value":0.08333333333333333,"label":"1/16 Triplet"}],"description":"LFO rate as a fraction of the global BPM."},{"id":"waveform","name":"Waveform","type":"select","defaultValue":"sine","options":[{"value":"sine","label":"Sine"},{"value":"square","label":"Square"},{"value":"sawtooth","label":"Sawtooth"},{"value":"triangle","label":"Triangle"}],"description":"LFO waveform shape."},{"id":"gain","name":"Amplitude","type":"slider","defaultValue":1,"min":0,"max":10,"step":0.1,"description":"Amplitude of the LFO signal (controls internal GainNode)."}],"logicCode":"// This block is implemented natively by the browser (e.g., OscillatorNode, BiquadFilterNode, DelayNode, AnalyserNode, ConstantSourceNode).\n// Its AudioParams and properties are controlled by the audio engine (useAudioEngine.ts) based on UI changes ('params') and connected inputs (passed to engine).\n// This main-thread 'logicCode' does not process or output audio. 'inputs.audio_in' will be null.\n// Audio connections ('audio_in', 'audio_out', CV inputs) are part of the Web Audio API graph, managed by the host.\n// The 'audioContextInfo' object in scope may contain { sampleRate: number, bpm: number }.\n// __custom_block_logger__('Native Block: Main-thread tick. Parameters for the native AudioNode are managed by the host audio engine.');\nreturn {}; // No internal state change by default.","initialPrompt":"Create a native LFO block synchronized to global BPM. It should use an OscillatorNode. Parameters: bpm_fraction (select from common musical divisions like 1/4, 1/8, 1/16, triplets, dotted), waveform, amplitude. Output: LFO audio signal. The host audio engine will calculate the actual frequency based on global BPM and the selected fraction.","isAiGenerated":false},{"id":"native-ad-envelope-v1","name":"AD Envelope (Native)","description":"Attack-Decay envelope generator using a native ConstantSourceNode and AudioParam automation. Triggered by input signal.","runsAtAudioRate":true,"inputs":[{"id":"trigger_in","name":"Trigger","type":"trigger","description":"Triggers the envelope."}],"outputs":[{"id":"audio_out","name":"Envelope Output","type":"audio","description":"The envelope signal (0 to Peak Level)."}],"parameters":[{"id":"attackTime","name":"Attack Time (s)","type":"slider","defaultValue":0.1,"min":0.001,"max":5,"step":0.001,"description":"Envelope attack time in seconds."},{"id":"decayTime","name":"Decay Time (s)","type":"slider","defaultValue":0.3,"min":0.001,"max":5,"step":0.001,"description":"Envelope decay time in seconds."},{"id":"peakLevel","name":"Peak Level","type":"slider","defaultValue":1,"min":0,"max":10,"step":0.1,"description":"Peak level of the envelope."}],"logicCode":"// This logic code detects a rising edge on 'trigger_in' and manages envelopeNeedsTriggering.\n// The actual envelope generation is handled by useAudioEngine using ConstantSourceNode and AudioParam ramps.\n\nconst triggerInputVal = inputs.trigger_in;\nlet newInternalState = { ...internalState }; // Make a mutable copy\n\nif (triggerInputVal === true && (internalState.prevTriggerState === false || internalState.prevTriggerState === undefined || internalState.prevTriggerState === null)) {\n  newInternalState.envelopeNeedsTriggering = true;\n  __custom_block_logger__('AD Envelope trigger detected. Setting envelopeNeedsTriggering to true.');\n}\n\nnewInternalState.prevTriggerState = triggerInputVal;\n\nreturn newInternalState;","initialPrompt":"Create a native AD (Attack-Decay) envelope generator. It should use a ConstantSourceNode and AudioParam automation (linearRampToValueAtTime). Parameters: attackTime (s), decayTime (s), peakLevel. Input: trigger_in. Output: envelope audio signal. The main-thread logicCode should detect the trigger and inform the host audio engine to start the ramps.","isAiGenerated":false},{"id":"native-ar-envelope-v1","name":"AR Envelope (Native)","description":"Attack-Release envelope generator using a native ConstantSourceNode and AudioParam automation. Controlled by a gate input.","runsAtAudioRate":true,"inputs":[{"id":"gate_in","name":"Gate","type":"gate","description":"Controls the envelope state (high for attack/sustain, low for release)."}],"outputs":[{"id":"audio_out","name":"Envelope Output","type":"audio","description":"The envelope signal (0 to Sustain Level)."}],"parameters":[{"id":"attackTime","name":"Attack Time (s)","type":"slider","defaultValue":0.1,"min":0.001,"max":5,"step":0.001,"description":"Envelope attack time in seconds."},{"id":"releaseTime","name":"Release Time (s)","type":"slider","defaultValue":0.5,"min":0.001,"max":5,"step":0.001,"description":"Envelope release time in seconds."},{"id":"sustainLevel","name":"Sustain Level","type":"slider","defaultValue":0.7,"min":0,"max":10,"step":0.1,"description":"Sustain level of the envelope (when gate is high)."}],"logicCode":"// This logic code detects changes in 'gate_in' and sets flags for the host audio engine.\n// The actual envelope generation is handled by useAudioEngine.\n\nconst gateInputVal = !!inputs.gate_in; // Ensure boolean\nlet newInternalState = { ...internalState };\n\n// Detect rising edge (gate becomes true)\nif (gateInputVal === true && (internalState.prevGateState === false || internalState.prevGateState === undefined)) {\n  newInternalState.gateStateChangedToHigh = true;\n  newInternalState.gateStateChangedToLow = false; // Ensure only one state change per tick\n  __custom_block_logger__('AR Envelope gate became HIGH. Setting gateStateChangedToHigh.');\n}\n// Detect falling edge (gate becomes false)\nelse if (gateInputVal === false && internalState.prevGateState === true) {\n  newInternalState.gateStateChangedToLow = true;\n  newInternalState.gateStateChangedToHigh = false; // Ensure only one state change per tick\n  __custom_block_logger__('AR Envelope gate became LOW. Setting gateStateChangedToLow.');\n} else {\n  // No change, or consecutive same states, clear flags\n  newInternalState.gateStateChangedToHigh = false;\n  newInternalState.gateStateChangedToLow = false;\n}\n\nnewInternalState.prevGateState = gateInputVal;\n\nreturn newInternalState;","initialPrompt":"Create a native AR (Attack-Release) envelope generator. It should use a ConstantSourceNode and AudioParam automation. Parameters: attackTime (s), releaseTime (s), sustainLevel. Input: gate_in (boolean type, high for attack/sustain, low for release). Output: envelope audio signal. The main-thread logicCode should detect gate changes and inform the host audio engine.","isAiGenerated":false},{"id":"number-to-constant-audio-v1","name":"Number to Constant Audio","description":"Converts a number input to a constant audio signal via ConstantSourceNode, with gain control.","runsAtAudioRate":true,"inputs":[{"id":"number_in","name":"Number In","type":"number","description":"Numeric value to output as constant audio."}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"Constant audio signal."}],"parameters":[{"id":"gain","name":"Gain","type":"slider","defaultValue":1,"min":0,"max":1,"step":0.01,"description":"Gain applied to the constant audio signal."},{"id":"max_input_value","name":"Max Expected Input","type":"number_input","defaultValue":255,"min":1,"description":"Expected maximum of number_in, for normalization to -1 to 1 range before gain."}],"logicCode":"// Main thread logic for Number to Constant Audio.\n// The 'number_in' value will be read by useAudioEngine and used to set the ConstantSourceNode's offset.\n// The 'gain' parameter is also handled by useAudioEngine for an internal GainNode.\n// The 'max_input_value' param helps useAudioEngine normalize the number_in to an audio range like -1 to 1.\n\n// This logic code is a placeholder as primary functionality is in the audio engine.\n// It can be used for logging or reacting to non-audio related changes if any.\n// For example, if number_in was intended to set a state variable that then gets read by worklet.\n// But for ConstantSourceNode, the engine directly uses inputs.number_in.\n\nconst numIn = inputs.number_in;\n// __custom_block_logger__(`Number input received: ${numIn}. Audio engine handles ConstantSourceNode.`);\n\n// No outputs from logic code itself, audio is from native node.\nreturn {};","initialPrompt":"Create a block that converts a number input to a constant audio signal. Use a native ConstantSourceNode. Parameters: \"Gain\" (slider 0-1) for an internal GainNode, \"Max Expected Input\" (number_input, e.g., 255 for 8-bit numbers) to normalize the input number to audio range (-1 to 1) before applying gain. Input: \"Number In\". Output: \"Audio Output\". The audio engine will manage the ConstantSourceNode and GainNode.","isAiGenerated":false},{"id":"gain-v1","name":"Gain Control (Native)","description":"Wraps a native Web Audio API GainNode. Amplifies or attenuates an audio signal. Its \"gain\" parameter controls the GainNode.gain AudioParam. Audio path is managed by Web Audio graph connections.","runsAtAudioRate":true,"inputs":[{"id":"audio_in","name":"Audio Input","type":"audio","description":"Signal to process (connects to native GainNode input in Web Audio graph)"},{"id":"gain_cv_in","name":"Gain CV","type":"audio","description":"Modulates gain AudioParam directly in Web Audio graph.","audioParamTarget":"gain"}],"outputs":[{"id":"audio_out","name":"Audio Output","type":"audio","description":"Processed audio signal (from native GainNode output in Web Audio graph)"}],"parameters":[{"id":"gain","name":"Gain Factor","type":"slider","defaultValue":1,"min":0,"max":2,"step":0.01,"description":"Gain multiplier (AudioParam for native GainNode)"}],"logicCode":"// This block wraps a native GainNode. Its 'gain' parameter is an AudioParam, updated by the host.\n// 'audio_in', 'audio_out', 'gain_cv_in' represent connections in the Web Audio graph.\n// This logicCode does not process audio or directly manage AudioParams.\n// Any main-thread logic specific to this block (e.g., reacting to non-audio inputs/params) would go here.\n// Currently, it's a simple pass-through for control logic, as the host handles native node parameter updates.\n// __custom_block_logger__('Native Gain Block: Main-thread tick. Parameters are for the native GainNode managed by the host.');\nreturn {};","initialPrompt":"Create a gain control block that wraps a native Web Audio API GainNode. It should take an audio input and a gain CV input (for direct AudioParam modulation). It should have a \"gain\" parameter (slider from 0 to 2) that controls the native GainNode's gain AudioParam. It should output the processed audio signal.","isAiGenerated":false}],"_blockInstances":[{"instanceId":"inst_0a8f332c-8594-4138-9478-c511f5e7389b","definitionId":"system-audio-output-v1","name":"Audio Output 1","position":{"x":560,"y":100},"logs":["02:55:51 - Worklet system not ready, deferring setup.","02:55:51 - Worklet system not ready, deferring setup.","01:27:29 - Audio system not active. Node now requires setup.","01:27:28 - Worklet node setup successful.","01:27:28 - Worklet node setup initiated by AudioNodeManager.","01:27:26 - Audio system not active. Node now requires setup.","00:55:48 - Worklet node setup successful.","00:55:48 - Worklet node setup initiated by AudioNodeManager.","00:55:47 - Worklet system not ready, deferring setup.","00:55:47 - Worklet system not ready, deferring setup.","20:53:07 - Audio system not active. Node now requires setup.","20:53:06 - Worklet node setup successful.","20:53:06 - Worklet node setup initiated by AudioNodeManager.","20:52:48 - Audio system not active. Node now requires setup.","20:52:46 - Worklet node setup successful.","20:52:46 - Worklet node setup initiated by AudioNodeManager.","20:52:38 - Audio system not active. Node now requires setup.","20:52:37 - Worklet node setup successful.","20:52:37 - Worklet node setup initiated by AudioNodeManager.","20:52:27 - Audio system not active. Node now requires setup.","20:52:13 - Worklet node setup successful.","20:52:13 - Worklet node setup initiated by AudioNodeManager.","20:52:13 - Worklet system not ready, deferring setup.","20:52:13 - Worklet system not ready, deferring setup.","20:25:26 - Audio system not active. Node now requires setup.","20:25:21 - Worklet node setup successful.","20:25:21 - Worklet node setup initiated by AudioNodeManager.","20:25:21 - Worklet system not ready, deferring setup.","20:25:21 - Worklet system not ready, deferring setup.","18:52:20 - Audio system not active. Node now requires setup.","18:52:16 - Worklet node setup successful.","18:52:16 - Worklet node setup initiated by AudioNodeManager.","17:30:02 - Audio system not active. Node now requires setup.","17:30:01 - Worklet node setup successful.","17:30:01 - Worklet node setup initiated by AudioNodeManager.","17:28:13 - Audio system not active. Node now requires setup.","17:28:08 - Worklet node setup successful.","17:28:08 - Worklet node setup initiated by AudioNodeManager.","17:28:06 - Audio system not active. Node now requires setup.","17:28:02 - Worklet node setup successful.","17:28:02 - Worklet node setup initiated by AudioNodeManager.","17:28:01 - Worklet system not ready, deferring setup.","17:28:01 - Worklet system not ready, deferring setup.","17:20:14 - Audio system not active. Node now requires setup.","17:20:05 - Worklet node setup successful.","17:20:05 - Worklet node setup initiated by AudioNodeManager.","17:20:05 - Worklet system not ready, deferring setup.","17:20:05 - Worklet system not ready, deferring setup.","17:13:22 - Audio system not active. Node now requires setup.","17:13:13 - Worklet node setup successful."],"parameters":[{"id":"volume","name":"Volume","type":"slider","min":0,"max":1,"step":0.01,"description":"Output volume level (controls an internal GainNode AudioParam)","defaultValue":0.7,"currentValue":0.7}],"internalState":{"needsAudioNodeSetup":true,"loggedWorkletSystemNotReady":true,"loggedAudioSystemNotActive":true,"lyriaServiceReady":false,"autoPlayInitiated":false},"lastRunOutputs":{},"modificationPrompts":[]},{"instanceId":"inst_9adf95af-d730-4b97-8e9c-e5db1e513049","definitionId":"native-oscillator-v1","name":"Oscillator (Native) 1","position":{"x":100,"y":20},"logs":["22:19:54 - Audio system not active. Node now requires setup.","22:19:53 - Native node setup successful.","22:19:53 - Native node setup initiated by AudioNodeManager.","22:17:35 - Audio system not active. Node now requires setup.","22:17:34 - Native node setup successful.","22:17:34 - Native node setup initiated by AudioNodeManager.","22:09:31 - Audio system not active. Node now requires setup.","22:09:30 - Native node setup successful.","22:09:30 - Native node setup initiated by AudioNodeManager.","22:08:15 - Audio system not active. Node now requires setup.","22:08:13 - Native node setup successful.","22:08:13 - Native node setup initiated by AudioNodeManager.","21:53:29 - Audio system not active. Node now requires setup.","21:53:26 - Native node setup successful.","21:53:26 - Native node setup initiated by AudioNodeManager.","21:50:08 - Audio system not active. Node now requires setup.","21:50:04 - Native node setup successful.","21:50:04 - Native node setup initiated by AudioNodeManager.","21:41:29 - Audio system not active. Node now requires setup.","21:41:25 - Native node setup successful.","21:41:25 - Native node setup initiated by AudioNodeManager.","21:40:49 - Audio system not active. Node now requires setup.","21:40:46 - Native node setup successful.","21:40:46 - Native node setup initiated by AudioNodeManager.","21:37:24 - Audio system not active. Node now requires setup.","21:37:16 - Native node setup successful.","21:37:16 - Native node setup initiated by AudioNodeManager.","19:14:40 - Audio system not active. Node now requires setup.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup initiated by AudioNodeManager.","19:13:52 - Native node setup initiated by AudioNodeManager.","18:57:06 - Audio system not active. Node now requires setup.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:55:33 - Audio system not active. Node now requires setup.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:54:02 - Audio system not active. Node now requires setup.","18:53:59 - Native node setup successful.","18:53:59 - Native node setup initiated by AudioNodeManager.","18:44:39 - Audio system not active. Node now requires setup.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup initiated by AudioNodeManager.","18:44:37 - Native node setup initiated by AudioNodeManager."],"parameters":[{"id":"frequency","name":"Frequency","type":"slider","min":20,"max":5000,"step":1,"description":"Base frequency in Hz (OscillatorNode.frequency).","defaultValue":440,"currentValue":440,"isFrequency":true},{"id":"waveform","name":"Waveform","type":"select","options":[{"value":"sine","label":"Sine"},{"value":"square","label":"Square"},{"value":"sawtooth","label":"Sawtooth"},{"value":"triangle","label":"Triangle"}],"description":"Shape of the waveform (OscillatorNode.type).","defaultValue":"sine","currentValue":"sine"},{"id":"gain","name":"Gain/CV Depth","type":"slider","min":0,"max":200,"step":0.1,"description":"Output amplitude or CV modulation depth. Controls an internal GainNode.","defaultValue":0.5,"currentValue":0.5}],"internalState":{"needsAudioNodeSetup":true,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":true,"lyriaServiceReady":false,"autoPlayInitiated":false},"lastRunOutputs":{"audio_out":0},"modificationPrompts":[]},{"instanceId":"inst_8c459ef0-7c06-4ff2-ac62-e2f43046507a","definitionId":"step-sequencer-v1","name":"Step Sequencer 1","position":{"x":40,"y":240},"logs":["21:50:06 - Step 5 triggered. Output: true","21:50:05 - Step 3 triggered. Output: true","21:50:04 - Step 1 triggered. Output: true","21:41:27 - Step 7 triggered. Output: true","21:41:25 - Step 5 triggered. Output: true","21:40:47 - Step 3 triggered. Output: true","21:37:24 - Step 1 triggered. Output: true","21:37:22 - Step 7 triggered. Output: true","21:37:21 - Step 5 triggered. Output: true","21:37:19 - Step 3 triggered. Output: true","21:37:18 - Step 1 triggered. Output: true","21:37:17 - Step 7 triggered. Output: true","19:14:38 - Step 5 triggered. Output: true","19:14:38 - Step 5 triggered. Output: true","19:14:35 - Step 3 triggered. Output: true","19:14:33 - Step 1 triggered. Output: true","18:57:04 - Step 7 triggered. Output: true","18:57:02 - Step 5 triggered. Output: true","18:57:01 - Step 3 triggered. Output: true","18:56:59 - Step 1 triggered. Output: true","18:55:32 - Step 7 triggered. Output: true","18:55:29 - Step 5 triggered. Output: true","18:54:01 - Step 3 triggered. Output: true","18:54:00 - Step 1 triggered. Output: true","18:44:38 - Step 7 triggered. Output: true","17:27:55 - Step 5 triggered. Output: true","17:27:54 - Step 3 triggered. Output: true","06:01:16 - Step 1 triggered. Output: true","06:01:14 - Step 7 triggered. Output: true","06:01:13 - Step 5 triggered. Output: true","06:01:12 - Step 3 triggered. Output: true","05:51:55 - Step 1 triggered. Output: true","05:51:53 - Step 7 triggered. Output: true","05:51:52 - Step 5 triggered. Output: true","05:51:51 - Step 3 triggered. Output: true","03:40:59 - Step 1 triggered. Output: true","03:40:57 - Step 7 triggered. Output: true","03:40:56 - Step 5 triggered. Output: true","02:59:02 - Step 3 triggered. Output: true","02:59:01 - Step 1 triggered. Output: true","02:58:59 - Step 7 triggered. Output: true","02:58:58 - Step 5 triggered. Output: true","02:58:57 - Step 3 triggered. Output: true","02:58:55 - Step 1 triggered. Output: true","02:58:54 - Step 7 triggered. Output: true","02:58:53 - Step 5 triggered. Output: true","02:58:52 - Step 3 triggered. Output: true","02:58:51 - Step 1 triggered. Output: true","02:58:49 - Step 7 triggered. Output: true","02:58:48 - Step 5 triggered. Output: true"],"parameters":[{"id":"steps_pattern","name":"Steps Pattern","type":"step_sequencer_ui","description":"Pattern of active steps.","defaultValue":[true,false,true,false,true,false,true,false],"currentValue":[true,false,true,false,true,false,true,false],"steps":8},{"id":"run_mode","name":"Run Mode","type":"select","options":[{"value":"internal_bpm","label":"Internal BPM"},{"value":"external_trigger","label":"External Trigger"}],"description":"Clock source for the sequencer.","defaultValue":"internal_bpm","currentValue":"internal_bpm"},{"id":"bpm_fraction_rate","name":"Rate (BPM Fraction)","type":"select","options":[{"value":4,"label":"1 Bar (4/4)"},{"value":2,"label":"1/2 Note"},{"value":1.5,"label":"Dotted 1/4 Note"},{"value":1,"label":"1/4 Note (Beat)"},{"value":0.75,"label":"Dotted 1/8 Note"},{"value":0.5,"label":"1/8 Note"},{"value":0.3333333333333333,"label":"1/4 Triplet"},{"value":0.25,"label":"1/16 Note"},{"value":0.16666666666666666,"label":"1/8 Triplet"},{"value":0.125,"label":"1/32 Note"},{"value":0.08333333333333333,"label":"1/16 Triplet"}],"description":"Sequencer step rate when in Internal BPM mode.","defaultValue":0.25,"currentValue":0.25},{"id":"num_steps","name":"Number of Steps","type":"slider","min":1,"max":16,"step":1,"description":"Total number of steps in the sequence.","defaultValue":8,"currentValue":8}],"internalState":{"needsAudioNodeSetup":false,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":false,"timeSinceLastInternalStep":3840,"prevExtTriggerState":null,"currentStepIndex":5},"lastRunOutputs":{"trigger_out":null,"gate_out":false},"modificationPrompts":[],"error":null},{"instanceId":"inst_9ea0d1e4-49cd-4efe-aaf3-1cc660d9b5f9","definitionId":"native-ad-envelope-v1","name":"AD Envelope (Native) 1","position":{"x":220,"y":280},"logs":["22:19:54 - Audio system not active. Node now requires setup.","22:19:53 - Native node setup successful.","22:19:53 - Native node setup initiated by AudioNodeManager.","22:17:34 - Native node setup successful.","22:17:34 - Native node setup initiated by AudioNodeManager.","22:09:31 - Audio system not active. Node now requires setup.","22:09:30 - Native node setup successful.","22:09:30 - Native node setup initiated by AudioNodeManager.","22:08:13 - Native node setup successful.","22:08:13 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup successful.","21:53:29 - Native node setup initiated by AudioNodeManager."],"parameters":[{"id":"attackTime","name":"Attack Time (s)","type":"slider","min":0.001,"max":5,"step":0.001,"description":"Envelope attack time in seconds.","defaultValue":0.1,"currentValue":0.319},{"id":"decayTime","name":"Decay Time (s)","type":"slider","min":0.001,"max":5,"step":0.001,"description":"Envelope decay time in seconds.","defaultValue":0.3,"currentValue":1.231},{"id":"peakLevel","name":"Peak Level","type":"slider","min":0,"max":10,"step":0.1,"description":"Peak level of the envelope.","defaultValue":1,"currentValue":1}],"internalState":{"needsAudioNodeSetup":true,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":true,"lyriaServiceReady":false,"prevTriggerState":null,"autoPlayInitiated":false,"envelopeNeedsTriggering":false},"lastRunOutputs":{"audio_out":0},"modificationPrompts":[],"error":null},{"instanceId":"inst_3b32f891-6a74-4c45-8fa3-e9407dc1e116","definitionId":"gain-v1","name":"Gain Control (Native) 1","position":{"x":380,"y":20},"logs":["22:19:53 - Native node setup failed.","22:19:53 - Native node setup initiated by AudioNodeManager.","22:17:34 - Native node setup failed.","22:17:34 - Native node setup initiated by AudioNodeManager.","22:09:30 - Native node setup failed.","22:09:30 - Native node setup initiated by AudioNodeManager.","22:08:13 - Native node setup failed.","22:08:13 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager.","21:53:29 - Native node setup failed.","21:53:29 - Native node setup initiated by AudioNodeManager."],"parameters":[{"id":"gain","name":"Gain Factor","type":"slider","min":0,"max":2,"step":0.01,"description":"Gain multiplier (AudioParam for native GainNode)","defaultValue":1,"currentValue":1}],"internalState":{"needsAudioNodeSetup":true,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":true,"lyriaServiceReady":false,"autoPlayInitiated":false},"lastRunOutputs":{"audio_out":0},"modificationPrompts":[],"error":null},{"instanceId":"inst_d924a043-41d3-49d5-a14a-ea7bc919c525","definitionId":"analyser-oscilloscope-v1","name":"Oscilloscope (Analyser) 1","position":{"x":241.70433763039878,"y":81.77869622103103},"logs":["22:19:54 - Audio system not active. Node now requires setup.","22:19:53 - Native node setup successful.","22:19:53 - Native node setup initiated by AudioNodeManager.","22:17:35 - Audio system not active. Node now requires setup.","22:17:34 - Native node setup successful.","22:17:34 - Native node setup initiated by AudioNodeManager.","22:09:31 - Audio system not active. Node now requires setup.","22:09:30 - Native node setup successful.","22:09:30 - Native node setup initiated by AudioNodeManager.","22:08:15 - Audio system not active. Node now requires setup.","22:08:13 - Native node setup successful.","22:08:13 - Native node setup initiated by AudioNodeManager.","21:53:29 - Audio system not active. Node now requires setup.","21:53:26 - Native node setup successful.","21:53:26 - Native node setup initiated by AudioNodeManager.","21:50:08 - Audio system not active. Node now requires setup.","21:50:04 - Native node setup successful.","21:50:04 - Native node setup initiated by AudioNodeManager.","21:41:29 - Audio system not active. Node now requires setup.","21:41:25 - Native node setup successful.","21:41:25 - Native node setup initiated by AudioNodeManager.","21:40:49 - Audio system not active. Node now requires setup.","21:40:46 - Native node setup successful.","21:40:46 - Native node setup initiated by AudioNodeManager.","21:37:24 - Audio system not active. Node now requires setup.","21:37:16 - Native node setup successful.","21:37:16 - Native node setup initiated by AudioNodeManager.","19:14:40 - Audio system not active. Node now requires setup.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup initiated by AudioNodeManager.","19:13:52 - Native node setup initiated by AudioNodeManager.","18:57:06 - Audio system not active. Node now requires setup.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:55:33 - Audio system not active. Node now requires setup.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:54:02 - Audio system not active. Node now requires setup.","18:53:59 - Native node setup successful.","18:53:59 - Native node setup initiated by AudioNodeManager.","18:44:39 - Audio system not active. Node now requires setup.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup initiated by AudioNodeManager.","18:44:37 - Native node setup initiated by AudioNodeManager."],"parameters":[{"id":"fftSize","name":"FFT Size","type":"select","options":[{"value":32,"label":"32"},{"value":64,"label":"64"},{"value":128,"label":"128"},{"value":256,"label":"256"},{"value":512,"label":"512"},{"value":1024,"label":"1024"},{"value":2048,"label":"2048"},{"value":4096,"label":"4096"},{"value":8192,"label":"8192"},{"value":16384,"label":"16384"},{"value":32768,"label":"32768"}],"description":"Size of the FFT window. This influences the detail in the time domain data for the oscilloscope.","defaultValue":2048,"currentValue":2048}],"internalState":{"needsAudioNodeSetup":true,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":true,"lyriaServiceReady":false,"autoPlayInitiated":false},"lastRunOutputs":{},"modificationPrompts":[]},{"instanceId":"inst_0b67c30e-f93b-4136-b304-b6ae0e60b49a","definitionId":"byte-reverse-v1","name":"Byte Reverse 1","position":{"x":60,"y":120},"logs":["Instance 'Byte Reverse 1' created."],"parameters":[{"id":"num_bits_N","name":"Number of Bits (N)","type":"slider","min":1,"max":16,"step":1,"description":"Number of LSBs to consider for reversal.","defaultValue":8,"currentValue":8}],"internalState":{"needsAudioNodeSetup":false,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":false},"lastRunOutputs":{"reversed_number_out":0},"modificationPrompts":[]},{"instanceId":"inst_61f4106c-f855-4d28-bf85-fafa6abba1ff","definitionId":"native-oscillator-v1","name":"Oscillator (Native) 2","position":{"x":380,"y":240},"logs":["22:19:54 - Audio system not active. Node now requires setup.","22:19:53 - Native node setup successful.","22:19:53 - Native node setup initiated by AudioNodeManager.","22:17:35 - Audio system not active. Node now requires setup.","22:17:34 - Native node setup successful.","22:17:34 - Native node setup initiated by AudioNodeManager.","22:09:31 - Audio system not active. Node now requires setup.","22:09:30 - Native node setup successful.","22:09:30 - Native node setup initiated by AudioNodeManager.","22:08:15 - Audio system not active. Node now requires setup.","22:08:13 - Native node setup successful.","22:08:13 - Native node setup initiated by AudioNodeManager.","21:53:29 - Audio system not active. Node now requires setup.","21:53:26 - Native node setup successful.","21:53:26 - Native node setup initiated by AudioNodeManager.","21:50:08 - Audio system not active. Node now requires setup.","21:50:04 - Native node setup successful.","21:50:04 - Native node setup initiated by AudioNodeManager.","21:41:29 - Audio system not active. Node now requires setup.","21:41:25 - Native node setup successful.","21:41:25 - Native node setup initiated by AudioNodeManager.","21:40:49 - Audio system not active. Node now requires setup.","21:40:46 - Native node setup successful.","21:40:46 - Native node setup initiated by AudioNodeManager.","21:37:24 - Audio system not active. Node now requires setup.","21:37:16 - Native node setup successful.","21:37:16 - Native node setup initiated by AudioNodeManager.","19:14:40 - Audio system not active. Node now requires setup.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup initiated by AudioNodeManager.","19:13:52 - Native node setup initiated by AudioNodeManager.","18:57:06 - Audio system not active. Node now requires setup.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:55:33 - Audio system not active. Node now requires setup.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:54:02 - Audio system not active. Node now requires setup.","18:53:59 - Native node setup successful.","18:53:59 - Native node setup initiated by AudioNodeManager.","18:44:39 - Audio system not active. Node now requires setup.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup initiated by AudioNodeManager.","18:44:37 - Native node setup initiated by AudioNodeManager."],"parameters":[{"id":"frequency","name":"Frequency","type":"slider","min":20,"max":5000,"step":1,"description":"Base frequency in Hz (OscillatorNode.frequency).","defaultValue":440,"currentValue":244,"isFrequency":true},{"id":"waveform","name":"Waveform","type":"select","options":[{"value":"sine","label":"Sine"},{"value":"square","label":"Square"},{"value":"sawtooth","label":"Sawtooth"},{"value":"triangle","label":"Triangle"}],"description":"Shape of the waveform (OscillatorNode.type).","defaultValue":"sine","currentValue":"sine"},{"id":"gain","name":"Gain/CV Depth","type":"slider","min":0,"max":200,"step":0.1,"description":"Output amplitude or CV modulation depth. Controls an internal GainNode.","defaultValue":0.5,"currentValue":0.5}],"internalState":{"needsAudioNodeSetup":true,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":true,"lyriaServiceReady":false,"autoPlayInitiated":false},"lastRunOutputs":{"audio_out":0},"modificationPrompts":[]},{"instanceId":"inst_4b7fbcda-92a3-42a2-bcf1-e94c2ea311fc","definitionId":"native-lfo-v1","name":"LFO (Native) 1","position":{"x":260,"y":180},"logs":["22:19:54 - Audio system not active. Node now requires setup.","22:19:53 - Native node setup successful.","22:19:53 - Native node setup initiated by AudioNodeManager.","22:17:35 - Audio system not active. Node now requires setup.","22:17:34 - Native node setup successful.","22:17:34 - Native node setup initiated by AudioNodeManager.","22:09:31 - Audio system not active. Node now requires setup.","22:09:30 - Native node setup successful.","22:09:30 - Native node setup initiated by AudioNodeManager.","22:08:15 - Audio system not active. Node now requires setup.","22:08:13 - Native node setup successful.","22:08:13 - Native node setup initiated by AudioNodeManager.","21:53:29 - Audio system not active. Node now requires setup.","21:53:26 - Native node setup successful.","21:53:26 - Native node setup initiated by AudioNodeManager.","21:50:08 - Audio system not active. Node now requires setup.","21:50:04 - Native node setup successful.","21:50:04 - Native node setup initiated by AudioNodeManager.","21:41:29 - Audio system not active. Node now requires setup.","21:41:25 - Native node setup successful.","21:41:25 - Native node setup initiated by AudioNodeManager.","21:40:49 - Audio system not active. Node now requires setup.","21:40:46 - Native node setup successful.","21:40:46 - Native node setup initiated by AudioNodeManager.","21:37:24 - Audio system not active. Node now requires setup.","21:37:16 - Native node setup successful.","21:37:16 - Native node setup initiated by AudioNodeManager.","19:14:40 - Audio system not active. Node now requires setup.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup successful.","19:13:52 - Native node setup initiated by AudioNodeManager.","19:13:52 - Native node setup initiated by AudioNodeManager.","18:57:06 - Audio system not active. Node now requires setup.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup successful.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:56:58 - Native node setup initiated by AudioNodeManager.","18:55:33 - Audio system not active. Node now requires setup.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup successful.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:55:28 - Native node setup initiated by AudioNodeManager.","18:54:02 - Audio system not active. Node now requires setup.","18:53:59 - Native node setup successful.","18:53:59 - Native node setup initiated by AudioNodeManager.","18:44:39 - Audio system not active. Node now requires setup.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup successful.","18:44:37 - Native node setup initiated by AudioNodeManager.","18:44:37 - Native node setup initiated by AudioNodeManager."],"parameters":[{"id":"frequency","name":"Frequency (Hz)","type":"slider","min":0.01,"max":200,"step":0.01,"description":"LFO frequency in Hz.","defaultValue":1,"currentValue":200,"isFrequency":true},{"id":"waveform","name":"Waveform","type":"select","options":[{"value":"sine","label":"Sine"},{"value":"square","label":"Square"},{"value":"sawtooth","label":"Sawtooth"},{"value":"triangle","label":"Triangle"}],"description":"LFO waveform shape.","defaultValue":"sine","currentValue":"sine"},{"id":"gain","name":"Amplitude","type":"slider","min":0,"max":10,"step":0.1,"description":"Amplitude of the LFO signal (controls internal GainNode).","defaultValue":1,"currentValue":1}],"internalState":{"needsAudioNodeSetup":true,"loggedWorkletSystemNotReady":false,"loggedAudioSystemNotActive":true,"lyriaServiceReady":false,"autoPlayInitiated":false},"lastRunOutputs":{"audio_out":0},"modificationPrompts":[],"error":null}]}}