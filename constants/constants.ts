import { BlockParameter } from '@interfaces/block';

// Helper to correctly type and initialize parameter definitions for BlockDefinition objects.
export const createParameterDefinitions = (
  params: Array<Omit<BlockParameter, 'currentValue' | 'defaultValue'> & { defaultValue: any, steps?: number, isFrequency?: boolean }>
): BlockParameter[] => {
  return params.map(pDefProto => {
    let typedDefaultValue = pDefProto.defaultValue;
    if (pDefProto.type === 'slider' || pDefProto.type === 'knob' || pDefProto.type === 'number_input') {
      const parsedDefault = parseFloat(pDefProto.defaultValue as string);
      typedDefaultValue = !isNaN(parsedDefault) ? parsedDefault : (pDefProto.min !== undefined ? parseFloat(pDefProto.min as any) : 0);
    } else if (pDefProto.type === 'toggle') {
      typedDefaultValue = typeof pDefProto.defaultValue === 'boolean' ? pDefProto.defaultValue : String(pDefProto.defaultValue).toLowerCase() === 'true';
    } else if (pDefProto.type === 'select' && pDefProto.options && pDefProto.options.length > 0) {
      const defaultOptionExists = pDefProto.options.find(opt => opt.value === pDefProto.defaultValue);
      typedDefaultValue = defaultOptionExists ? pDefProto.defaultValue : pDefProto.options[0].value;
    } else if (pDefProto.type === 'step_sequencer_ui') {
      const numSteps = typeof pDefProto.steps === 'number' && pDefProto.steps > 0 ? pDefProto.steps : 4;
      typedDefaultValue = (Array.isArray(pDefProto.defaultValue) && pDefProto.defaultValue.length === numSteps && pDefProto.defaultValue.every(val => typeof val === 'boolean'))
        ? pDefProto.defaultValue
        : Array(numSteps).fill(false);
    }
    return {
      ...pDefProto,
      defaultValue: typedDefaultValue,
    };
  });
};

export const BPM_FRACTIONS = [
  { value: 4, label: '1 Bar (4/4)' }, { value: 2, label: '1/2 Note' }, { value: 1, label: '1/4 Note (Beat)' },
  { value: 0.5, label: '1/8 Note' }, { value: 0.25, label: '1/16 Note' }, { value: 0.125, label: '1/32 Note' },
  { value: 1 / 3, label: '1/4 Triplet' }, { value: 1 / 6, label: '1/8 Triplet' }, { value: 1 / 12, label: '1/16 Triplet' },
  { value: 0.75, label: 'Dotted 1/8 Note' }, { value: 1.5, label: 'Dotted 1/4 Note' }
];
BPM_FRACTIONS.sort((a, b) => b.value - a.value); // Sort from longest to shortest duration for UI

// export const NUMBER_TO_CONSTANT_AUDIO_BLOCK_DEFINITION: BlockDefinition = {
//   id: 'number-to-constant-audio-v1',
//   name: 'Number to Constant Audio',
//   description: 'Converts a number input to a constant audio signal via ConstantSourceNode, with gain control.',
//   runsAtAudioRate: true,
//   inputs: [
//     { id: 'number_in', name: 'Number In', type: 'number', description: 'Numeric value to output as constant audio.' }
//   ],
//   outputs: [
//     { id: 'audio_out', name: 'Audio Output', type: 'audio', description: 'Constant audio signal.' }
//   ],
//   parameters: createParameterDefinitions([
//     { id: 'gain', name: 'Gain', type: 'slider', min: 0, max: 1, step: 0.01, defaultValue: 1, description: 'Gain applied to the constant audio signal.' },
//     { id: 'max_input_value', name: 'Max Expected Input', type: 'number_input', min: 1, defaultValue: 255, description: 'Expected maximum of number_in, for normalization to -1 to 1 range before gain.' }
//   ]),
//   // logicCode: "", // Removed
// };

export const GEMINI_SYSTEM_PROMPT_FOR_BLOCK_DEFINITION = `
You are an expert in Web Audio API and creative audio programming.
You will be given a user prompt to create an audio processing block.
Respond with a JSON object matching the BlockDefinition interface.
The BlockDefinition interface is:
export interface BlockDefinition {
  id: string; // Unique ID, e.g., "my-filter-v1", "custom-synth-v1"
  name: string; // User-friendly name, e.g., "My Custom Filter", "Advanced Synthesizer"
  description?: string; // Optional brief description of what the block does
  inputs: BlockPort[]; // Array of input ports
  outputs: BlockPort[]; // Array of output ports
  parameters: BlockParameterDefinition[]; // Array of parameters that can be controlled by the user
  initialPrompt: string; // The original user prompt that led to this definition.
  runsAtAudioRate?: boolean; // True if this block involves Web Audio API nodes or AudioWorklets directly processing/generating audio.
  audioWorkletProcessorName?: string; // If using an AudioWorklet, its registered name (e.g., "my-processor").
  audioWorkletCode?: string; // Full JavaScript code for the AudioWorkletProcessor class. Do NOT include registerProcessor call.
  isAiGenerated?: boolean; // Should be true for blocks generated by you.
}
export interface BlockPort { id: string; name: string; type: 'number'|'string'|'boolean'|'audio'|'trigger'|'any'|'gate'; description?: string; audioParamTarget?: string; }
export interface BlockParameterDefinition { id: string; name: string; type: 'slider'|'knob'|'toggle'|'select'|'number_input'|'text_input'|'step_sequencer_ui'; options?: Array<{value: string|number; label: string}>; min?: number; max?: number; step?: number; defaultValue: any; description?: string; steps?: number; isFrequency?: boolean; }

Guidelines for BlockDefinition:
- ID: Lowercase, hyphenated, versioned (e.g., "user-delay-v1").
- Name: Title Case, user-friendly.
- Ports:
  - Type 'audio': For Web Audio signal paths. If an input port of type 'audio' is intended to directly modulate an AudioParam of a native node or an AudioWorkletNode, its 'id' should conventionally be like 'paramName_cv_in' (e.g., 'freq_cv_in') and its 'audioParamTarget' field should be set to the exact AudioParam name (e.g., 'frequency').
  - Type 'trigger': For momentary events (e.g., note on, reset). Value is true for one tick, then null.
  - Type 'gate': For sustained signals (e.g., note hold). Value is true while active, false otherwise.
  - Type 'any': For flexible data types, like complex objects or arrays.
- Parameters:
  - 'defaultValue' must be correctly typed (number for slider/knob/number_input, boolean for toggle, string/number for select, string for text_input, boolean[] for step_sequencer_ui).
  - For step_sequencer_ui: 'steps' defines the number of steps. 'defaultValue' is a boolean array of this length.
  - For number_input with 'isFrequency: true', it implies the input field can accept direct Hz values or note names like "A4", "C#3".
- If \`runsAtAudioRate\` is true, you usually need an AudioWorklet. Provide \`audioWorkletProcessorName\` and \`audioWorkletCode\`.
- \`audioWorkletCode\` should define a class extending \`AudioWorkletProcessor\`. The host will handle \`registerProcessor\`.
- runsAtAudioRate: True if it generates/processes audio with Web Audio API (native nodes or worklets). False for pure logic/data blocks.
- isAiGenerated: Always true.
- Ensure all string literals within JSON are properly escaped.
- Do not include comments in the final JSON output.

Respond ONLY with the single JSON BlockDefinition object. Do not add any explanatory text outside the JSON.
`.trim();

export const GEMINI_SYSTEM_PROMPT_FOR_CODE_MODIFICATION = `
You are an expert in JavaScript and Web Audio API.
You will be given JavaScript code of an audio block, its definition context (inputs, outputs, parameters), and a user request for modification.
The code runs in a function scope with \`inputs\`, \`params\`, \`internalState\`, \`setOutput\`, \`__custom_block_logger__\`, \`audioContextInfo\`, \`postMessageToWorklet\` available.
It must return the new \`internalState\`.

Your task is to provide the MODIFIED code based on the user's request.
Respond with a JSON object: \`{ "modifiedLogicCode": "...", "reasoning": "..." }\`.
"reasoning" should be a brief explanation of the changes made.
Ensure \`modifiedLogicCode\` is a string containing only the function body.
Do not include comments in the \`modifiedLogicCode\` string itself unless specifically part of the logic.
Only provide the JSON object.
`.trim();

export const GEMINI_SYSTEM_PROMPT_FOR_TEST_FIXING_LOGIC_CODE = `
You are an expert in JavaScript debugging and testing.
You will receive: the original user prompt for a block, the block's definition (inputs, outputs, parameters), the failing 'code', the tests that were run, and the details of the test failures.
Your task is to analyze the failures and provide a corrected 'code'.
The code runs in a function scope with 'inputs', 'params', 'internalState', 'setOutput', '__custom_block_logger__', 'audioContextInfo', 'postMessageToWorklet' available. It must return the new 'internalState'.
Respond with a JSON object: \`{ "fixedCode": "...", "analysis": "Brief analysis of why tests failed and how code was fixed." }\`.
Ensure 'fixedCode' is a string containing only the function body. Only provide the JSON object.
`.trim();

export const GEMINI_SYSTEM_PROMPT_FOR_TEST_FIXING_TEST_CODE = `
You are an expert in JavaScript testing and Web Audio block logic.
You will receive: the original user prompt for a block, the block's definition (inputs, outputs, parameters), the code for the block, the current tests that are problematic, and the reason the tests are suspected to be flawed (e.g., test failures that seem to indicate issues with the tests themselves, or a request to improve test coverage).
Your task is to analyze the code and the existing tests, then provide a corrected or improved tests string.
The tests use a Jest-like syntax: describe, it, expect. The 'it' callback receives a context: { TestedLogic(inputs, params, internalState), getOutputs(), getLogs(), resetTestContext() }.
Respond with a JSON object: \`{ "fixedLogicCodeTests": "...", "analysis": "Brief analysis of the issues with the original tests and how they were improved." }\`.
Ensure 'fixedLogicCodeTests' is a string containing the test code. Only provide the JSON object.
`.trim();
